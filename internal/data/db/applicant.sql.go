// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: applicant.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createApplicant = `-- name: CreateApplicant :one
INSERT INTO applicants (
    head_type, identity_number, tax_id, full_name, birth_date, establishment_date, created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, head_type, identity_number, tax_id, full_name, birth_date, establishment_date, created_at, created_by, updated_at, deleted_at
`

type CreateApplicantParams struct {
	HeadType          string         `json:"head_type"`
	IdentityNumber    sql.NullString `json:"identity_number"`
	TaxID             sql.NullString `json:"tax_id"`
	FullName          sql.NullString `json:"full_name"`
	BirthDate         sql.NullTime   `json:"birth_date"`
	EstablishmentDate sql.NullTime   `json:"establishment_date"`
	CreatedBy         uuid.NullUUID  `json:"created_by"`
}

func (q *Queries) CreateApplicant(ctx context.Context, arg CreateApplicantParams) (Applicant, error) {
	row := q.db.QueryRowContext(ctx, createApplicant,
		arg.HeadType,
		arg.IdentityNumber,
		arg.TaxID,
		arg.FullName,
		arg.BirthDate,
		arg.EstablishmentDate,
		arg.CreatedBy,
	)
	var i Applicant
	err := row.Scan(
		&i.ID,
		&i.HeadType,
		&i.IdentityNumber,
		&i.TaxID,
		&i.FullName,
		&i.BirthDate,
		&i.EstablishmentDate,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createAttributeRegistry = `-- name: CreateAttributeRegistry :exec
INSERT INTO custom_column_attribute_registries (
    attribute_code, applies_to, scope, value_type, risk_relevant, description
) VALUES (
    $1, $2, $3, $4, $5, $6
) ON CONFLICT (attribute_code) DO UPDATE SET
    applies_to = EXCLUDED.applies_to,
    scope = EXCLUDED.scope,
    value_type = EXCLUDED.value_type,
    risk_relevant = EXCLUDED.risk_relevant,
    description = EXCLUDED.description
`

type CreateAttributeRegistryParams struct {
	AttributeCode string         `json:"attribute_code"`
	AppliesTo     string         `json:"applies_to"`
	Scope         string         `json:"scope"`
	ValueType     string         `json:"value_type"`
	RiskRelevant  sql.NullBool   `json:"risk_relevant"`
	Description   sql.NullString `json:"description"`
}

func (q *Queries) CreateAttributeRegistry(ctx context.Context, arg CreateAttributeRegistryParams) error {
	_, err := q.db.ExecContext(ctx, createAttributeRegistry,
		arg.AttributeCode,
		arg.AppliesTo,
		arg.Scope,
		arg.ValueType,
		arg.RiskRelevant,
		arg.Description,
	)
	return err
}

const deleteApplicantAttributes = `-- name: DeleteApplicantAttributes :exec
DELETE FROM applicant_attributes WHERE applicant_id = $1
`

func (q *Queries) DeleteApplicantAttributes(ctx context.Context, applicantID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteApplicantAttributes, applicantID)
	return err
}

const getApplicant = `-- name: GetApplicant :one
SELECT id, head_type, identity_number, tax_id, full_name, birth_date, establishment_date, created_at, created_by, updated_at, deleted_at FROM applicants WHERE id = $1 LIMIT 1
`

func (q *Queries) GetApplicant(ctx context.Context, id uuid.UUID) (Applicant, error) {
	row := q.db.QueryRowContext(ctx, getApplicant, id)
	var i Applicant
	err := row.Scan(
		&i.ID,
		&i.HeadType,
		&i.IdentityNumber,
		&i.TaxID,
		&i.FullName,
		&i.BirthDate,
		&i.EstablishmentDate,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getApplicantAttributes = `-- name: GetApplicantAttributes :many
SELECT id, applicant_id, attr_key, attr_value, data_type, updated_at FROM applicant_attributes WHERE applicant_id = $1
`

func (q *Queries) GetApplicantAttributes(ctx context.Context, applicantID uuid.UUID) ([]ApplicantAttribute, error) {
	rows, err := q.db.QueryContext(ctx, getApplicantAttributes, applicantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApplicantAttribute
	for rows.Next() {
		var i ApplicantAttribute
		if err := rows.Scan(
			&i.ID,
			&i.ApplicantID,
			&i.AttrKey,
			&i.AttrValue,
			&i.DataType,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listApplicantAttributesByIDs = `-- name: ListApplicantAttributesByIDs :many
SELECT id, applicant_id, attr_key, attr_value, data_type, updated_at FROM applicant_attributes WHERE applicant_id = ANY($1::uuid[])
`

func (q *Queries) ListApplicantAttributesByIDs(ctx context.Context, dollar_1 []uuid.UUID) ([]ApplicantAttribute, error) {
	rows, err := q.db.QueryContext(ctx, listApplicantAttributesByIDs, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApplicantAttribute
	for rows.Next() {
		var i ApplicantAttribute
		if err := rows.Scan(
			&i.ID,
			&i.ApplicantID,
			&i.AttrKey,
			&i.AttrValue,
			&i.DataType,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listApplicants = `-- name: ListApplicants :many
SELECT id, head_type, identity_number, tax_id, full_name, birth_date, establishment_date, created_at, created_by, updated_at, deleted_at FROM applicants 
WHERE (
    ($2::timestamp IS NULL AND $3::uuid IS NULL)
    OR (created_at, id) < ($2::timestamp, $3::uuid)
  )
ORDER BY created_at DESC, id DESC
LIMIT $1
`

type ListApplicantsParams struct {
	Limit           int32         `json:"limit"`
	CursorCreatedAt sql.NullTime  `json:"cursor_created_at"`
	CursorID        uuid.NullUUID `json:"cursor_id"`
}

func (q *Queries) ListApplicants(ctx context.Context, arg ListApplicantsParams) ([]Applicant, error) {
	rows, err := q.db.QueryContext(ctx, listApplicants, arg.Limit, arg.CursorCreatedAt, arg.CursorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Applicant
	for rows.Next() {
		var i Applicant
		if err := rows.Scan(
			&i.ID,
			&i.HeadType,
			&i.IdentityNumber,
			&i.TaxID,
			&i.FullName,
			&i.BirthDate,
			&i.EstablishmentDate,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAttributeRegistry = `-- name: ListAttributeRegistry :many
SELECT attribute_code, applies_to, scope, value_type, risk_relevant, description FROM custom_column_attribute_registries
`

func (q *Queries) ListAttributeRegistry(ctx context.Context) ([]CustomColumnAttributeRegistry, error) {
	rows, err := q.db.QueryContext(ctx, listAttributeRegistry)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CustomColumnAttributeRegistry
	for rows.Next() {
		var i CustomColumnAttributeRegistry
		if err := rows.Scan(
			&i.AttributeCode,
			&i.AppliesTo,
			&i.Scope,
			&i.ValueType,
			&i.RiskRelevant,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateApplicant = `-- name: UpdateApplicant :one
UPDATE applicants SET 
    head_type = $2,
    identity_number = $3,
    tax_id = $4,
    full_name = $5,
    birth_date = $6,
    establishment_date = $7
WHERE id = $1 RETURNING id, head_type, identity_number, tax_id, full_name, birth_date, establishment_date, created_at, created_by, updated_at, deleted_at
`

type UpdateApplicantParams struct {
	ID                uuid.UUID      `json:"id"`
	HeadType          string         `json:"head_type"`
	IdentityNumber    sql.NullString `json:"identity_number"`
	TaxID             sql.NullString `json:"tax_id"`
	FullName          sql.NullString `json:"full_name"`
	BirthDate         sql.NullTime   `json:"birth_date"`
	EstablishmentDate sql.NullTime   `json:"establishment_date"`
}

func (q *Queries) UpdateApplicant(ctx context.Context, arg UpdateApplicantParams) (Applicant, error) {
	row := q.db.QueryRowContext(ctx, updateApplicant,
		arg.ID,
		arg.HeadType,
		arg.IdentityNumber,
		arg.TaxID,
		arg.FullName,
		arg.BirthDate,
		arg.EstablishmentDate,
	)
	var i Applicant
	err := row.Scan(
		&i.ID,
		&i.HeadType,
		&i.IdentityNumber,
		&i.TaxID,
		&i.FullName,
		&i.BirthDate,
		&i.EstablishmentDate,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const upsertApplicantAttribute = `-- name: UpsertApplicantAttribute :one
INSERT INTO applicant_attributes (applicant_id, attr_key, attr_value, data_type)
VALUES ($1, $2, $3, $4)
ON CONFLICT (applicant_id, attr_key) DO UPDATE SET 
    attr_value = EXCLUDED.attr_value,
    data_type = EXCLUDED.data_type,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, applicant_id, attr_key, attr_value, data_type, updated_at
`

type UpsertApplicantAttributeParams struct {
	ApplicantID uuid.UUID      `json:"applicant_id"`
	AttrKey     string         `json:"attr_key"`
	AttrValue   sql.NullString `json:"attr_value"`
	DataType    sql.NullString `json:"data_type"`
}

func (q *Queries) UpsertApplicantAttribute(ctx context.Context, arg UpsertApplicantAttributeParams) (ApplicantAttribute, error) {
	row := q.db.QueryRowContext(ctx, upsertApplicantAttribute,
		arg.ApplicantID,
		arg.AttrKey,
		arg.AttrValue,
		arg.DataType,
	)
	var i ApplicantAttribute
	err := row.Scan(
		&i.ID,
		&i.ApplicantID,
		&i.AttrKey,
		&i.AttrValue,
		&i.DataType,
		&i.UpdatedAt,
	)
	return i, err
}

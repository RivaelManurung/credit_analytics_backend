// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: applicant.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createApplicant = `-- name: CreateApplicant :one
INSERT INTO applicants (
        applicant_type,
        identity_number,
        tax_id,
        full_name,
        birth_date,
        establishment_date,
        created_by
    )
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, applicant_type, identity_number, tax_id, full_name, birth_date, establishment_date, created_at, created_by
`

type CreateApplicantParams struct {
	ApplicantType     string         `json:"applicant_type"`
	IdentityNumber    sql.NullString `json:"identity_number"`
	TaxID             sql.NullString `json:"tax_id"`
	FullName          sql.NullString `json:"full_name"`
	BirthDate         sql.NullTime   `json:"birth_date"`
	EstablishmentDate sql.NullTime   `json:"establishment_date"`
	CreatedBy         uuid.NullUUID  `json:"created_by"`
}

func (q *Queries) CreateApplicant(ctx context.Context, arg CreateApplicantParams) (Applicant, error) {
	row := q.db.QueryRowContext(ctx, createApplicant,
		arg.ApplicantType,
		arg.IdentityNumber,
		arg.TaxID,
		arg.FullName,
		arg.BirthDate,
		arg.EstablishmentDate,
		arg.CreatedBy,
	)
	var i Applicant
	err := row.Scan(
		&i.ID,
		&i.ApplicantType,
		&i.IdentityNumber,
		&i.TaxID,
		&i.FullName,
		&i.BirthDate,
		&i.EstablishmentDate,
		&i.CreatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const deleteApplicantAttributes = `-- name: DeleteApplicantAttributes :exec
DELETE FROM applicant_attributes
WHERE applicant_id = $1
`

func (q *Queries) DeleteApplicantAttributes(ctx context.Context, applicantID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteApplicantAttributes, applicantID)
	return err
}

const getApplicant = `-- name: GetApplicant :one
SELECT id, applicant_type, identity_number, tax_id, full_name, birth_date, establishment_date, created_at, created_by
FROM applicants
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetApplicant(ctx context.Context, id uuid.UUID) (Applicant, error) {
	row := q.db.QueryRowContext(ctx, getApplicant, id)
	var i Applicant
	err := row.Scan(
		&i.ID,
		&i.ApplicantType,
		&i.IdentityNumber,
		&i.TaxID,
		&i.FullName,
		&i.BirthDate,
		&i.EstablishmentDate,
		&i.CreatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getApplicantAttributes = `-- name: GetApplicantAttributes :many
SELECT id, applicant_id, attribute_id, attribute_option_id, attr_value, data_type, updated_at
FROM applicant_attributes
WHERE applicant_id = $1
`

func (q *Queries) GetApplicantAttributes(ctx context.Context, applicantID uuid.UUID) ([]ApplicantAttribute, error) {
	rows, err := q.db.QueryContext(ctx, getApplicantAttributes, applicantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApplicantAttribute
	for rows.Next() {
		var i ApplicantAttribute
		if err := rows.Scan(
			&i.ID,
			&i.ApplicantID,
			&i.AttributeID,
			&i.AttributeOptionID,
			&i.AttrValue,
			&i.DataType,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listApplicantAttributesByIDs = `-- name: ListApplicantAttributesByIDs :many
SELECT id, applicant_id, attribute_id, attribute_option_id, attr_value, data_type, updated_at
FROM applicant_attributes
WHERE applicant_id = ANY($1::text[]::uuid[])
`

func (q *Queries) ListApplicantAttributesByIDs(ctx context.Context, dollar_1 []string) ([]ApplicantAttribute, error) {
	rows, err := q.db.QueryContext(ctx, listApplicantAttributesByIDs, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApplicantAttribute
	for rows.Next() {
		var i ApplicantAttribute
		if err := rows.Scan(
			&i.ID,
			&i.ApplicantID,
			&i.AttributeID,
			&i.AttributeOptionID,
			&i.AttrValue,
			&i.DataType,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listApplicants = `-- name: ListApplicants :many
SELECT id, applicant_type, identity_number, tax_id, full_name, birth_date, establishment_date, created_at, created_by
FROM applicants
WHERE (
        (
            $2::timestamp IS NULL
            AND $3::uuid IS NULL
        )
        OR (created_at, id) < (
            $2::timestamp,
            $3::uuid
        )
    )
ORDER BY created_at DESC,
    id DESC
LIMIT $1
`

type ListApplicantsParams struct {
	Limit           int32         `json:"limit"`
	CursorCreatedAt sql.NullTime  `json:"cursor_created_at"`
	CursorID        uuid.NullUUID `json:"cursor_id"`
}

func (q *Queries) ListApplicants(ctx context.Context, arg ListApplicantsParams) ([]Applicant, error) {
	rows, err := q.db.QueryContext(ctx, listApplicants, arg.Limit, arg.CursorCreatedAt, arg.CursorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Applicant
	for rows.Next() {
		var i Applicant
		if err := rows.Scan(
			&i.ID,
			&i.ApplicantType,
			&i.IdentityNumber,
			&i.TaxID,
			&i.FullName,
			&i.BirthDate,
			&i.EstablishmentDate,
			&i.CreatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateApplicant = `-- name: UpdateApplicant :one
UPDATE applicants
SET applicant_type = $2,
    identity_number = $3,
    tax_id = $4,
    full_name = $5,
    birth_date = $6,
    establishment_date = $7
WHERE id = $1
RETURNING id, applicant_type, identity_number, tax_id, full_name, birth_date, establishment_date, created_at, created_by
`

type UpdateApplicantParams struct {
	ID                uuid.UUID      `json:"id"`
	ApplicantType     string         `json:"applicant_type"`
	IdentityNumber    sql.NullString `json:"identity_number"`
	TaxID             sql.NullString `json:"tax_id"`
	FullName          sql.NullString `json:"full_name"`
	BirthDate         sql.NullTime   `json:"birth_date"`
	EstablishmentDate sql.NullTime   `json:"establishment_date"`
}

func (q *Queries) UpdateApplicant(ctx context.Context, arg UpdateApplicantParams) (Applicant, error) {
	row := q.db.QueryRowContext(ctx, updateApplicant,
		arg.ID,
		arg.ApplicantType,
		arg.IdentityNumber,
		arg.TaxID,
		arg.FullName,
		arg.BirthDate,
		arg.EstablishmentDate,
	)
	var i Applicant
	err := row.Scan(
		&i.ID,
		&i.ApplicantType,
		&i.IdentityNumber,
		&i.TaxID,
		&i.FullName,
		&i.BirthDate,
		&i.EstablishmentDate,
		&i.CreatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const upsertApplicantAttribute = `-- name: UpsertApplicantAttribute :one
INSERT INTO applicant_attributes (
        applicant_id,
        attribute_id,
        attribute_option_id,
        attr_value,
        data_type
    )
VALUES ($1, $2, $3, $4, $5) ON CONFLICT (applicant_id, attribute_id) DO
UPDATE
SET attribute_option_id = EXCLUDED.attribute_option_id,
    attr_value = EXCLUDED.attr_value,
    data_type = EXCLUDED.data_type,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, applicant_id, attribute_id, attribute_option_id, attr_value, data_type, updated_at
`

type UpsertApplicantAttributeParams struct {
	ApplicantID       uuid.UUID      `json:"applicant_id"`
	AttributeID       uuid.UUID      `json:"attribute_id"`
	AttributeOptionID uuid.NullUUID  `json:"attribute_option_id"`
	AttrValue         sql.NullString `json:"attr_value"`
	DataType          sql.NullString `json:"data_type"`
}

func (q *Queries) UpsertApplicantAttribute(ctx context.Context, arg UpsertApplicantAttributeParams) (ApplicantAttribute, error) {
	row := q.db.QueryRowContext(ctx, upsertApplicantAttribute,
		arg.ApplicantID,
		arg.AttributeID,
		arg.AttributeOptionID,
		arg.AttrValue,
		arg.DataType,
	)
	var i ApplicantAttribute
	err := row.Scan(
		&i.ID,
		&i.ApplicantID,
		&i.AttributeID,
		&i.AttributeOptionID,
		&i.AttrValue,
		&i.DataType,
		&i.UpdatedAt,
	)
	return i, err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: financial.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createAsset = `-- name: CreateAsset :one
INSERT INTO application_assets (
    application_id, asset_type_code, asset_name, ownership_status, 
    acquisition_year, estimated_value, valuation_method, location_text, encumbered
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING id, application_id, asset_type_code, asset_name, ownership_status, acquisition_year, estimated_value, valuation_method, location_text, encumbered, created_at
`

type CreateAssetParams struct {
	ApplicationID   uuid.UUID      `json:"application_id"`
	AssetTypeCode   sql.NullString `json:"asset_type_code"`
	AssetName       sql.NullString `json:"asset_name"`
	OwnershipStatus sql.NullString `json:"ownership_status"`
	AcquisitionYear sql.NullInt32  `json:"acquisition_year"`
	EstimatedValue  sql.NullString `json:"estimated_value"`
	ValuationMethod sql.NullString `json:"valuation_method"`
	LocationText    sql.NullString `json:"location_text"`
	Encumbered      sql.NullBool   `json:"encumbered"`
}

func (q *Queries) CreateAsset(ctx context.Context, arg CreateAssetParams) (ApplicationAsset, error) {
	row := q.db.QueryRowContext(ctx, createAsset,
		arg.ApplicationID,
		arg.AssetTypeCode,
		arg.AssetName,
		arg.OwnershipStatus,
		arg.AcquisitionYear,
		arg.EstimatedValue,
		arg.ValuationMethod,
		arg.LocationText,
		arg.Encumbered,
	)
	var i ApplicationAsset
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.AssetTypeCode,
		&i.AssetName,
		&i.OwnershipStatus,
		&i.AcquisitionYear,
		&i.EstimatedValue,
		&i.ValuationMethod,
		&i.LocationText,
		&i.Encumbered,
		&i.CreatedAt,
	)
	return i, err
}

const createLiability = `-- name: CreateLiability :one
INSERT INTO application_liabilities (
    application_id, creditor_name, liability_type, outstanding_amount, 
    monthly_installment, interest_rate, maturity_date, source
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id, application_id, creditor_name, liability_type, outstanding_amount, monthly_installment, interest_rate, maturity_date, source, created_at
`

type CreateLiabilityParams struct {
	ApplicationID      uuid.UUID      `json:"application_id"`
	CreditorName       sql.NullString `json:"creditor_name"`
	LiabilityType      sql.NullString `json:"liability_type"`
	OutstandingAmount  sql.NullString `json:"outstanding_amount"`
	MonthlyInstallment sql.NullString `json:"monthly_installment"`
	InterestRate       sql.NullString `json:"interest_rate"`
	MaturityDate       sql.NullTime   `json:"maturity_date"`
	Source             sql.NullString `json:"source"`
}

func (q *Queries) CreateLiability(ctx context.Context, arg CreateLiabilityParams) (ApplicationLiability, error) {
	row := q.db.QueryRowContext(ctx, createLiability,
		arg.ApplicationID,
		arg.CreditorName,
		arg.LiabilityType,
		arg.OutstandingAmount,
		arg.MonthlyInstallment,
		arg.InterestRate,
		arg.MaturityDate,
		arg.Source,
	)
	var i ApplicationLiability
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.CreditorName,
		&i.LiabilityType,
		&i.OutstandingAmount,
		&i.MonthlyInstallment,
		&i.InterestRate,
		&i.MaturityDate,
		&i.Source,
		&i.CreatedAt,
	)
	return i, err
}

const listAssets = `-- name: ListAssets :many
SELECT id, application_id, asset_type_code, asset_name, ownership_status, acquisition_year, estimated_value, valuation_method, location_text, encumbered, created_at FROM application_assets WHERE application_id = $1
`

func (q *Queries) ListAssets(ctx context.Context, applicationID uuid.UUID) ([]ApplicationAsset, error) {
	rows, err := q.db.QueryContext(ctx, listAssets, applicationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApplicationAsset
	for rows.Next() {
		var i ApplicationAsset
		if err := rows.Scan(
			&i.ID,
			&i.ApplicationID,
			&i.AssetTypeCode,
			&i.AssetName,
			&i.OwnershipStatus,
			&i.AcquisitionYear,
			&i.EstimatedValue,
			&i.ValuationMethod,
			&i.LocationText,
			&i.Encumbered,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFinancialFacts = `-- name: ListFinancialFacts :many
SELECT id, application_id, gl_code, period_type, period_label, amount, source, confidence_level, created_at FROM application_financial_facts WHERE application_id = $1
`

func (q *Queries) ListFinancialFacts(ctx context.Context, applicationID uuid.UUID) ([]ApplicationFinancialFact, error) {
	rows, err := q.db.QueryContext(ctx, listFinancialFacts, applicationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApplicationFinancialFact
	for rows.Next() {
		var i ApplicationFinancialFact
		if err := rows.Scan(
			&i.ID,
			&i.ApplicationID,
			&i.GlCode,
			&i.PeriodType,
			&i.PeriodLabel,
			&i.Amount,
			&i.Source,
			&i.ConfidenceLevel,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGLAccounts = `-- name: ListGLAccounts :many
SELECT gl_code, gl_name, statement_type, category, sign, is_debt_service, is_operating, description FROM financial_gl_accounts
`

func (q *Queries) ListGLAccounts(ctx context.Context) ([]FinancialGlAccount, error) {
	rows, err := q.db.QueryContext(ctx, listGLAccounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FinancialGlAccount
	for rows.Next() {
		var i FinancialGlAccount
		if err := rows.Scan(
			&i.GlCode,
			&i.GlName,
			&i.StatementType,
			&i.Category,
			&i.Sign,
			&i.IsDebtService,
			&i.IsOperating,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLiabilities = `-- name: ListLiabilities :many
SELECT id, application_id, creditor_name, liability_type, outstanding_amount, monthly_installment, interest_rate, maturity_date, source, created_at FROM application_liabilities WHERE application_id = $1
`

func (q *Queries) ListLiabilities(ctx context.Context, applicationID uuid.UUID) ([]ApplicationLiability, error) {
	rows, err := q.db.QueryContext(ctx, listLiabilities, applicationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApplicationLiability
	for rows.Next() {
		var i ApplicationLiability
		if err := rows.Scan(
			&i.ID,
			&i.ApplicationID,
			&i.CreditorName,
			&i.LiabilityType,
			&i.OutstandingAmount,
			&i.MonthlyInstallment,
			&i.InterestRate,
			&i.MaturityDate,
			&i.Source,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAsset = `-- name: UpdateAsset :one
UPDATE application_assets SET
    asset_type_code = $2,
    asset_name = $3,
    ownership_status = $4,
    acquisition_year = $5,
    estimated_value = $6,
    valuation_method = $7,
    location_text = $8,
    encumbered = $9
WHERE id = $1 RETURNING id, application_id, asset_type_code, asset_name, ownership_status, acquisition_year, estimated_value, valuation_method, location_text, encumbered, created_at
`

type UpdateAssetParams struct {
	ID              uuid.UUID      `json:"id"`
	AssetTypeCode   sql.NullString `json:"asset_type_code"`
	AssetName       sql.NullString `json:"asset_name"`
	OwnershipStatus sql.NullString `json:"ownership_status"`
	AcquisitionYear sql.NullInt32  `json:"acquisition_year"`
	EstimatedValue  sql.NullString `json:"estimated_value"`
	ValuationMethod sql.NullString `json:"valuation_method"`
	LocationText    sql.NullString `json:"location_text"`
	Encumbered      sql.NullBool   `json:"encumbered"`
}

func (q *Queries) UpdateAsset(ctx context.Context, arg UpdateAssetParams) (ApplicationAsset, error) {
	row := q.db.QueryRowContext(ctx, updateAsset,
		arg.ID,
		arg.AssetTypeCode,
		arg.AssetName,
		arg.OwnershipStatus,
		arg.AcquisitionYear,
		arg.EstimatedValue,
		arg.ValuationMethod,
		arg.LocationText,
		arg.Encumbered,
	)
	var i ApplicationAsset
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.AssetTypeCode,
		&i.AssetName,
		&i.OwnershipStatus,
		&i.AcquisitionYear,
		&i.EstimatedValue,
		&i.ValuationMethod,
		&i.LocationText,
		&i.Encumbered,
		&i.CreatedAt,
	)
	return i, err
}

const updateLiability = `-- name: UpdateLiability :one
UPDATE application_liabilities SET
    creditor_name = $2,
    liability_type = $3,
    outstanding_amount = $4,
    monthly_installment = $5,
    interest_rate = $6,
    maturity_date = $7,
    source = $8
WHERE id = $1 RETURNING id, application_id, creditor_name, liability_type, outstanding_amount, monthly_installment, interest_rate, maturity_date, source, created_at
`

type UpdateLiabilityParams struct {
	ID                 uuid.UUID      `json:"id"`
	CreditorName       sql.NullString `json:"creditor_name"`
	LiabilityType      sql.NullString `json:"liability_type"`
	OutstandingAmount  sql.NullString `json:"outstanding_amount"`
	MonthlyInstallment sql.NullString `json:"monthly_installment"`
	InterestRate       sql.NullString `json:"interest_rate"`
	MaturityDate       sql.NullTime   `json:"maturity_date"`
	Source             sql.NullString `json:"source"`
}

func (q *Queries) UpdateLiability(ctx context.Context, arg UpdateLiabilityParams) (ApplicationLiability, error) {
	row := q.db.QueryRowContext(ctx, updateLiability,
		arg.ID,
		arg.CreditorName,
		arg.LiabilityType,
		arg.OutstandingAmount,
		arg.MonthlyInstallment,
		arg.InterestRate,
		arg.MaturityDate,
		arg.Source,
	)
	var i ApplicationLiability
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.CreditorName,
		&i.LiabilityType,
		&i.OutstandingAmount,
		&i.MonthlyInstallment,
		&i.InterestRate,
		&i.MaturityDate,
		&i.Source,
		&i.CreatedAt,
	)
	return i, err
}

const upsertFinancialFact = `-- name: UpsertFinancialFact :one
INSERT INTO application_financial_facts (
    application_id, gl_code, period_type, period_label, amount, source, confidence_level
) VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (application_id, gl_code, period_type, period_label) DO UPDATE SET
    amount = EXCLUDED.amount,
    source = EXCLUDED.source,
    confidence_level = EXCLUDED.confidence_level
RETURNING id, application_id, gl_code, period_type, period_label, amount, source, confidence_level, created_at
`

type UpsertFinancialFactParams struct {
	ApplicationID   uuid.UUID      `json:"application_id"`
	GlCode          string         `json:"gl_code"`
	PeriodType      string         `json:"period_type"`
	PeriodLabel     string         `json:"period_label"`
	Amount          string         `json:"amount"`
	Source          sql.NullString `json:"source"`
	ConfidenceLevel sql.NullString `json:"confidence_level"`
}

func (q *Queries) UpsertFinancialFact(ctx context.Context, arg UpsertFinancialFactParams) (ApplicationFinancialFact, error) {
	row := q.db.QueryRowContext(ctx, upsertFinancialFact,
		arg.ApplicationID,
		arg.GlCode,
		arg.PeriodType,
		arg.PeriodLabel,
		arg.Amount,
		arg.Source,
		arg.ConfidenceLevel,
	)
	var i ApplicationFinancialFact
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.GlCode,
		&i.PeriodType,
		&i.PeriodLabel,
		&i.Amount,
		&i.Source,
		&i.ConfidenceLevel,
		&i.CreatedAt,
	)
	return i, err
}

const upsertFinancialRatio = `-- name: UpsertFinancialRatio :one
INSERT INTO application_financial_ratios (
    application_id, ratio_code, ratio_value, calculation_version
) VALUES ($1, $2, $3, $4)
ON CONFLICT (application_id, ratio_code) DO UPDATE SET
    ratio_value = EXCLUDED.ratio_value,
    calculation_version = EXCLUDED.calculation_version,
    calculated_at = CURRENT_TIMESTAMP
RETURNING id, application_id, ratio_code, ratio_value, calculation_version, calculated_at
`

type UpsertFinancialRatioParams struct {
	ApplicationID      uuid.UUID      `json:"application_id"`
	RatioCode          sql.NullString `json:"ratio_code"`
	RatioValue         sql.NullString `json:"ratio_value"`
	CalculationVersion sql.NullString `json:"calculation_version"`
}

func (q *Queries) UpsertFinancialRatio(ctx context.Context, arg UpsertFinancialRatioParams) (ApplicationFinancialRatio, error) {
	row := q.db.QueryRowContext(ctx, upsertFinancialRatio,
		arg.ApplicationID,
		arg.RatioCode,
		arg.RatioValue,
		arg.CalculationVersion,
	)
	var i ApplicationFinancialRatio
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.RatioCode,
		&i.RatioValue,
		&i.CalculationVersion,
		&i.CalculatedAt,
	)
	return i, err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: survey.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const assignSurvey = `-- name: AssignSurvey :one
INSERT INTO application_surveys (
    application_id, template_id, survey_type, status, assigned_to, survey_purpose
) VALUES ($1, $2, $3, 'ASSIGNED', $4, $5) RETURNING id, application_id, template_id, survey_type, status, submitted_by, verified_by, verified_at, assigned_to, survey_purpose, started_at, submitted_at
`

type AssignSurveyParams struct {
	ApplicationID uuid.NullUUID  `json:"application_id"`
	TemplateID    uuid.NullUUID  `json:"template_id"`
	SurveyType    sql.NullString `json:"survey_type"`
	AssignedTo    uuid.NullUUID  `json:"assigned_to"`
	SurveyPurpose sql.NullString `json:"survey_purpose"`
}

func (q *Queries) AssignSurvey(ctx context.Context, arg AssignSurveyParams) (ApplicationSurvey, error) {
	row := q.db.QueryRowContext(ctx, assignSurvey,
		arg.ApplicationID,
		arg.TemplateID,
		arg.SurveyType,
		arg.AssignedTo,
		arg.SurveyPurpose,
	)
	var i ApplicationSurvey
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.TemplateID,
		&i.SurveyType,
		&i.Status,
		&i.SubmittedBy,
		&i.VerifiedBy,
		&i.VerifiedAt,
		&i.AssignedTo,
		&i.SurveyPurpose,
		&i.StartedAt,
		&i.SubmittedAt,
	)
	return i, err
}

const createSurveyEvidence = `-- name: CreateSurveyEvidence :one
INSERT INTO survey_evidences (
    survey_id, evidence_type, file_url, description
) VALUES ($1, $2, $3, $4) RETURNING id, survey_id, evidence_type, file_url, description, captured_at
`

type CreateSurveyEvidenceParams struct {
	SurveyID     uuid.NullUUID  `json:"survey_id"`
	EvidenceType sql.NullString `json:"evidence_type"`
	FileUrl      sql.NullString `json:"file_url"`
	Description  sql.NullString `json:"description"`
}

func (q *Queries) CreateSurveyEvidence(ctx context.Context, arg CreateSurveyEvidenceParams) (SurveyEvidence, error) {
	row := q.db.QueryRowContext(ctx, createSurveyEvidence,
		arg.SurveyID,
		arg.EvidenceType,
		arg.FileUrl,
		arg.Description,
	)
	var i SurveyEvidence
	err := row.Scan(
		&i.ID,
		&i.SurveyID,
		&i.EvidenceType,
		&i.FileUrl,
		&i.Description,
		&i.CapturedAt,
	)
	return i, err
}

const createSurveyTemplate = `-- name: CreateSurveyTemplate :one
INSERT INTO survey_templates (
    template_code, template_name, applicant_type, product_id, active
) VALUES ($1, $2, $3, $4, $5) RETURNING id, template_code, template_name, applicant_type, product_id, active
`

type CreateSurveyTemplateParams struct {
	TemplateCode  sql.NullString `json:"template_code"`
	TemplateName  sql.NullString `json:"template_name"`
	ApplicantType sql.NullString `json:"applicant_type"`
	ProductID     uuid.NullUUID  `json:"product_id"`
	Active        sql.NullBool   `json:"active"`
}

func (q *Queries) CreateSurveyTemplate(ctx context.Context, arg CreateSurveyTemplateParams) (SurveyTemplate, error) {
	row := q.db.QueryRowContext(ctx, createSurveyTemplate,
		arg.TemplateCode,
		arg.TemplateName,
		arg.ApplicantType,
		arg.ProductID,
		arg.Active,
	)
	var i SurveyTemplate
	err := row.Scan(
		&i.ID,
		&i.TemplateCode,
		&i.TemplateName,
		&i.ApplicantType,
		&i.ProductID,
		&i.Active,
	)
	return i, err
}

const getSurvey = `-- name: GetSurvey :one
SELECT id, application_id, template_id, survey_type, status, submitted_by, verified_by, verified_at, assigned_to, survey_purpose, started_at, submitted_at FROM application_surveys WHERE id = $1
`

func (q *Queries) GetSurvey(ctx context.Context, id uuid.UUID) (ApplicationSurvey, error) {
	row := q.db.QueryRowContext(ctx, getSurvey, id)
	var i ApplicationSurvey
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.TemplateID,
		&i.SurveyType,
		&i.Status,
		&i.SubmittedBy,
		&i.VerifiedBy,
		&i.VerifiedAt,
		&i.AssignedTo,
		&i.SurveyPurpose,
		&i.StartedAt,
		&i.SubmittedAt,
	)
	return i, err
}

const getSurveyTemplateWithSections = `-- name: GetSurveyTemplateWithSections :many
SELECT 
    t.template_name, s.section_name, q.question_text, q.answer_type
FROM survey_templates t
JOIN survey_sections s ON s.template_id = t.id
JOIN survey_questions q ON q.section_id = s.id
WHERE t.id = $1
ORDER BY s.sequence, q.sequence
`

type GetSurveyTemplateWithSectionsRow struct {
	TemplateName sql.NullString `json:"template_name"`
	SectionName  sql.NullString `json:"section_name"`
	QuestionText sql.NullString `json:"question_text"`
	AnswerType   sql.NullString `json:"answer_type"`
}

func (q *Queries) GetSurveyTemplateWithSections(ctx context.Context, id uuid.UUID) ([]GetSurveyTemplateWithSectionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getSurveyTemplateWithSections, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSurveyTemplateWithSectionsRow
	for rows.Next() {
		var i GetSurveyTemplateWithSectionsRow
		if err := rows.Scan(
			&i.TemplateName,
			&i.SectionName,
			&i.QuestionText,
			&i.AnswerType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSurveyTemplates = `-- name: ListSurveyTemplates :many
SELECT id, template_code, template_name, applicant_type, product_id, active FROM survey_templates WHERE active = TRUE
`

func (q *Queries) ListSurveyTemplates(ctx context.Context) ([]SurveyTemplate, error) {
	rows, err := q.db.QueryContext(ctx, listSurveyTemplates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SurveyTemplate
	for rows.Next() {
		var i SurveyTemplate
		if err := rows.Scan(
			&i.ID,
			&i.TemplateCode,
			&i.TemplateName,
			&i.ApplicantType,
			&i.ProductID,
			&i.Active,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSurveyStatus = `-- name: UpdateSurveyStatus :one
UPDATE application_surveys SET 
    status = $2,
    started_at = CASE WHEN $2 = 'IN_PROGRESS' AND started_at IS NULL THEN CURRENT_TIMESTAMP ELSE started_at END,
    submitted_at = CASE WHEN $2 = 'SUBMITTED' THEN CURRENT_TIMESTAMP ELSE submitted_at END,
    submitted_by = CASE WHEN $2 = 'SUBMITTED' THEN $3 ELSE submitted_by END
WHERE id = $1 RETURNING id, application_id, template_id, survey_type, status, submitted_by, verified_by, verified_at, assigned_to, survey_purpose, started_at, submitted_at
`

type UpdateSurveyStatusParams struct {
	ID          uuid.UUID      `json:"id"`
	Status      sql.NullString `json:"status"`
	SubmittedBy uuid.NullUUID  `json:"submitted_by"`
}

func (q *Queries) UpdateSurveyStatus(ctx context.Context, arg UpdateSurveyStatusParams) (ApplicationSurvey, error) {
	row := q.db.QueryRowContext(ctx, updateSurveyStatus, arg.ID, arg.Status, arg.SubmittedBy)
	var i ApplicationSurvey
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.TemplateID,
		&i.SurveyType,
		&i.Status,
		&i.SubmittedBy,
		&i.VerifiedBy,
		&i.VerifiedAt,
		&i.AssignedTo,
		&i.SurveyPurpose,
		&i.StartedAt,
		&i.SubmittedAt,
	)
	return i, err
}

const upsertSurveyAnswer = `-- name: UpsertSurveyAnswer :one
INSERT INTO survey_answers (
    survey_id, question_id, answer_text, answer_number, answer_boolean, answer_date
) VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (survey_id, question_id) DO UPDATE SET
    answer_text = EXCLUDED.answer_text,
    answer_number = EXCLUDED.answer_number,
    answer_boolean = EXCLUDED.answer_boolean,
    answer_date = EXCLUDED.answer_date,
    answered_at = CURRENT_TIMESTAMP
RETURNING id, survey_id, question_id, answer_text, answer_number, answer_boolean, answer_date, answered_at
`

type UpsertSurveyAnswerParams struct {
	SurveyID      uuid.NullUUID  `json:"survey_id"`
	QuestionID    uuid.NullUUID  `json:"question_id"`
	AnswerText    sql.NullString `json:"answer_text"`
	AnswerNumber  sql.NullString `json:"answer_number"`
	AnswerBoolean sql.NullBool   `json:"answer_boolean"`
	AnswerDate    sql.NullTime   `json:"answer_date"`
}

func (q *Queries) UpsertSurveyAnswer(ctx context.Context, arg UpsertSurveyAnswerParams) (SurveyAnswer, error) {
	row := q.db.QueryRowContext(ctx, upsertSurveyAnswer,
		arg.SurveyID,
		arg.QuestionID,
		arg.AnswerText,
		arg.AnswerNumber,
		arg.AnswerBoolean,
		arg.AnswerDate,
	)
	var i SurveyAnswer
	err := row.Scan(
		&i.ID,
		&i.SurveyID,
		&i.QuestionID,
		&i.AnswerText,
		&i.AnswerNumber,
		&i.AnswerBoolean,
		&i.AnswerDate,
		&i.AnsweredAt,
	)
	return i, err
}

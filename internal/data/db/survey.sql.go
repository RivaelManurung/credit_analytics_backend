// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: survey.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const assignSurvey = `-- name: AssignSurvey :one
INSERT INTO application_surveys (
        application_id,
        template_id,
        survey_type,
        status,
        assigned_to,
        survey_purpose
    )
VALUES ($1, $2, $3, 'ASSIGNED', $4, $5)
RETURNING id, application_id, template_id, survey_type, status, submitted_by, verified_by, verified_at, assigned_to, survey_purpose, started_at, submitted_at
`

type AssignSurveyParams struct {
	ApplicationID uuid.NullUUID  `json:"application_id"`
	TemplateID    uuid.NullUUID  `json:"template_id"`
	SurveyType    sql.NullString `json:"survey_type"`
	AssignedTo    uuid.NullUUID  `json:"assigned_to"`
	SurveyPurpose sql.NullString `json:"survey_purpose"`
}

func (q *Queries) AssignSurvey(ctx context.Context, arg AssignSurveyParams) (ApplicationSurvey, error) {
	row := q.db.QueryRowContext(ctx, assignSurvey,
		arg.ApplicationID,
		arg.TemplateID,
		arg.SurveyType,
		arg.AssignedTo,
		arg.SurveyPurpose,
	)
	var i ApplicationSurvey
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.TemplateID,
		&i.SurveyType,
		&i.Status,
		&i.SubmittedBy,
		&i.VerifiedBy,
		&i.VerifiedAt,
		&i.AssignedTo,
		&i.SurveyPurpose,
		&i.StartedAt,
		&i.SubmittedAt,
	)
	return i, err
}

const createSurveyEvidence = `-- name: CreateSurveyEvidence :one
INSERT INTO survey_evidences (
        survey_id,
        evidence_type,
        file_url,
        description
    )
VALUES ($1, $2, $3, $4)
RETURNING id, survey_id, evidence_type, file_url, description, captured_at
`

type CreateSurveyEvidenceParams struct {
	SurveyID     uuid.NullUUID  `json:"survey_id"`
	EvidenceType sql.NullString `json:"evidence_type"`
	FileUrl      sql.NullString `json:"file_url"`
	Description  sql.NullString `json:"description"`
}

func (q *Queries) CreateSurveyEvidence(ctx context.Context, arg CreateSurveyEvidenceParams) (SurveyEvidence, error) {
	row := q.db.QueryRowContext(ctx, createSurveyEvidence,
		arg.SurveyID,
		arg.EvidenceType,
		arg.FileUrl,
		arg.Description,
	)
	var i SurveyEvidence
	err := row.Scan(
		&i.ID,
		&i.SurveyID,
		&i.EvidenceType,
		&i.FileUrl,
		&i.Description,
		&i.CapturedAt,
	)
	return i, err
}

const createSurveyTemplate = `-- name: CreateSurveyTemplate :one
INSERT INTO survey_templates (
        template_code,
        template_name,
        applicant_type,
        product_id,
        active
    )
VALUES ($1, $2, $3, $4, $5)
RETURNING id, template_code, template_name, applicant_type, product_id, active
`

type CreateSurveyTemplateParams struct {
	TemplateCode  sql.NullString `json:"template_code"`
	TemplateName  sql.NullString `json:"template_name"`
	ApplicantType sql.NullString `json:"applicant_type"`
	ProductID     uuid.NullUUID  `json:"product_id"`
	Active        sql.NullBool   `json:"active"`
}

func (q *Queries) CreateSurveyTemplate(ctx context.Context, arg CreateSurveyTemplateParams) (SurveyTemplate, error) {
	row := q.db.QueryRowContext(ctx, createSurveyTemplate,
		arg.TemplateCode,
		arg.TemplateName,
		arg.ApplicantType,
		arg.ProductID,
		arg.Active,
	)
	var i SurveyTemplate
	err := row.Scan(
		&i.ID,
		&i.TemplateCode,
		&i.TemplateName,
		&i.ApplicantType,
		&i.ProductID,
		&i.Active,
	)
	return i, err
}

const getSurvey = `-- name: GetSurvey :one
SELECT id, application_id, template_id, survey_type, status, submitted_by, verified_by, verified_at, assigned_to, survey_purpose, started_at, submitted_at
FROM application_surveys
WHERE id = $1
`

func (q *Queries) GetSurvey(ctx context.Context, id uuid.UUID) (ApplicationSurvey, error) {
	row := q.db.QueryRowContext(ctx, getSurvey, id)
	var i ApplicationSurvey
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.TemplateID,
		&i.SurveyType,
		&i.Status,
		&i.SubmittedBy,
		&i.VerifiedBy,
		&i.VerifiedAt,
		&i.AssignedTo,
		&i.SurveyPurpose,
		&i.StartedAt,
		&i.SubmittedAt,
	)
	return i, err
}

const getSurveyTemplateWithSections = `-- name: GetSurveyTemplateWithSections :many
SELECT t.template_name,
    s.section_name,
    q.question_text,
    q.answer_type
FROM survey_templates t
    JOIN survey_sections s ON s.template_id = t.id
    JOIN survey_questions q ON q.section_id = s.id
WHERE t.id = $1
ORDER BY s.sequence,
    q.sequence
`

type GetSurveyTemplateWithSectionsRow struct {
	TemplateName sql.NullString `json:"template_name"`
	SectionName  sql.NullString `json:"section_name"`
	QuestionText sql.NullString `json:"question_text"`
	AnswerType   sql.NullString `json:"answer_type"`
}

func (q *Queries) GetSurveyTemplateWithSections(ctx context.Context, id uuid.UUID) ([]GetSurveyTemplateWithSectionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getSurveyTemplateWithSections, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSurveyTemplateWithSectionsRow
	for rows.Next() {
		var i GetSurveyTemplateWithSectionsRow
		if err := rows.Scan(
			&i.TemplateName,
			&i.SectionName,
			&i.QuestionText,
			&i.AnswerType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSurveyTemplates = `-- name: ListSurveyTemplates :many
SELECT id, template_code, template_name, applicant_type, product_id, active
FROM survey_templates
WHERE active = TRUE
`

func (q *Queries) ListSurveyTemplates(ctx context.Context) ([]SurveyTemplate, error) {
	rows, err := q.db.QueryContext(ctx, listSurveyTemplates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SurveyTemplate
	for rows.Next() {
		var i SurveyTemplate
		if err := rows.Scan(
			&i.ID,
			&i.TemplateCode,
			&i.TemplateName,
			&i.ApplicantType,
			&i.ProductID,
			&i.Active,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSurveys = `-- name: ListSurveys :many
SELECT s.id, s.application_id, s.template_id, s.survey_type, s.status, s.submitted_by, s.verified_by, s.verified_at, s.assigned_to, s.survey_purpose, s.started_at, s.submitted_at,
    a.status AS application_status,
    app.full_name AS applicant_name
FROM application_surveys s
    JOIN applications a ON s.application_id = a.id
    JOIN applicants app ON a.applicant_id = app.id
WHERE (
        $2::text IS NULL
        OR s.status = $2
    )
    AND (
        $3::uuid IS NULL
        OR s.application_id = $3
    )
    AND (
        $4::uuid IS NULL
        OR s.assigned_to = $4
    )
    AND (
        $5::text IS NULL
        OR s.survey_type = $5
    )
    AND (
        ($6::uuid IS NULL)
        OR (s.id < $6::uuid)
    )
ORDER BY s.id DESC
LIMIT $1
`

type ListSurveysParams struct {
	Limit         int32          `json:"limit"`
	Status        sql.NullString `json:"status"`
	ApplicationID uuid.NullUUID  `json:"application_id"`
	AssignedTo    uuid.NullUUID  `json:"assigned_to"`
	SurveyType    sql.NullString `json:"survey_type"`
	CursorID      uuid.NullUUID  `json:"cursor_id"`
}

type ListSurveysRow struct {
	ID                uuid.UUID      `json:"id"`
	ApplicationID     uuid.NullUUID  `json:"application_id"`
	TemplateID        uuid.NullUUID  `json:"template_id"`
	SurveyType        sql.NullString `json:"survey_type"`
	Status            sql.NullString `json:"status"`
	SubmittedBy       uuid.NullUUID  `json:"submitted_by"`
	VerifiedBy        uuid.NullUUID  `json:"verified_by"`
	VerifiedAt        sql.NullTime   `json:"verified_at"`
	AssignedTo        uuid.NullUUID  `json:"assigned_to"`
	SurveyPurpose     sql.NullString `json:"survey_purpose"`
	StartedAt         sql.NullTime   `json:"started_at"`
	SubmittedAt       sql.NullTime   `json:"submitted_at"`
	ApplicationStatus string         `json:"application_status"`
	ApplicantName     sql.NullString `json:"applicant_name"`
}

func (q *Queries) ListSurveys(ctx context.Context, arg ListSurveysParams) ([]ListSurveysRow, error) {
	rows, err := q.db.QueryContext(ctx, listSurveys,
		arg.Limit,
		arg.Status,
		arg.ApplicationID,
		arg.AssignedTo,
		arg.SurveyType,
		arg.CursorID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSurveysRow
	for rows.Next() {
		var i ListSurveysRow
		if err := rows.Scan(
			&i.ID,
			&i.ApplicationID,
			&i.TemplateID,
			&i.SurveyType,
			&i.Status,
			&i.SubmittedBy,
			&i.VerifiedBy,
			&i.VerifiedAt,
			&i.AssignedTo,
			&i.SurveyPurpose,
			&i.StartedAt,
			&i.SubmittedAt,
			&i.ApplicationStatus,
			&i.ApplicantName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSurveysByApplication = `-- name: ListSurveysByApplication :many
SELECT id, application_id, template_id, survey_type, status, submitted_by, verified_by, verified_at, assigned_to, survey_purpose, started_at, submitted_at
FROM application_surveys
WHERE application_id = $1
`

func (q *Queries) ListSurveysByApplication(ctx context.Context, applicationID uuid.NullUUID) ([]ApplicationSurvey, error) {
	rows, err := q.db.QueryContext(ctx, listSurveysByApplication, applicationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApplicationSurvey
	for rows.Next() {
		var i ApplicationSurvey
		if err := rows.Scan(
			&i.ID,
			&i.ApplicationID,
			&i.TemplateID,
			&i.SurveyType,
			&i.Status,
			&i.SubmittedBy,
			&i.VerifiedBy,
			&i.VerifiedAt,
			&i.AssignedTo,
			&i.SurveyPurpose,
			&i.StartedAt,
			&i.SubmittedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSurveyStatus = `-- name: UpdateSurveyStatus :one
UPDATE application_surveys
SET status = $2,
    started_at = CASE
        WHEN $2 = 'IN_PROGRESS'
        AND started_at IS NULL THEN CURRENT_TIMESTAMP
        ELSE started_at
    END,
    submitted_at = CASE
        WHEN $2 = 'SUBMITTED' THEN CURRENT_TIMESTAMP
        ELSE submitted_at
    END,
    submitted_by = CASE
        WHEN $2 = 'SUBMITTED' THEN $3
        ELSE submitted_by
    END
WHERE id = $1
RETURNING id, application_id, template_id, survey_type, status, submitted_by, verified_by, verified_at, assigned_to, survey_purpose, started_at, submitted_at
`

type UpdateSurveyStatusParams struct {
	ID          uuid.UUID      `json:"id"`
	Status      sql.NullString `json:"status"`
	SubmittedBy uuid.NullUUID  `json:"submitted_by"`
}

func (q *Queries) UpdateSurveyStatus(ctx context.Context, arg UpdateSurveyStatusParams) (ApplicationSurvey, error) {
	row := q.db.QueryRowContext(ctx, updateSurveyStatus, arg.ID, arg.Status, arg.SubmittedBy)
	var i ApplicationSurvey
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.TemplateID,
		&i.SurveyType,
		&i.Status,
		&i.SubmittedBy,
		&i.VerifiedBy,
		&i.VerifiedAt,
		&i.AssignedTo,
		&i.SurveyPurpose,
		&i.StartedAt,
		&i.SubmittedAt,
	)
	return i, err
}

const upsertSurveyAnswer = `-- name: UpsertSurveyAnswer :one
INSERT INTO survey_answers (
        survey_id,
        question_id,
        answer_text,
        answer_number,
        answer_boolean,
        answer_date
    )
VALUES ($1, $2, $3, $4, $5, $6) ON CONFLICT (survey_id, question_id) DO
UPDATE
SET answer_text = EXCLUDED.answer_text,
    answer_number = EXCLUDED.answer_number,
    answer_boolean = EXCLUDED.answer_boolean,
    answer_date = EXCLUDED.answer_date,
    answered_at = CURRENT_TIMESTAMP
RETURNING id, survey_id, question_id, answer_text, answer_number, answer_boolean, answer_date, answered_at
`

type UpsertSurveyAnswerParams struct {
	SurveyID      uuid.NullUUID  `json:"survey_id"`
	QuestionID    uuid.NullUUID  `json:"question_id"`
	AnswerText    sql.NullString `json:"answer_text"`
	AnswerNumber  sql.NullString `json:"answer_number"`
	AnswerBoolean sql.NullBool   `json:"answer_boolean"`
	AnswerDate    sql.NullTime   `json:"answer_date"`
}

func (q *Queries) UpsertSurveyAnswer(ctx context.Context, arg UpsertSurveyAnswerParams) (SurveyAnswer, error) {
	row := q.db.QueryRowContext(ctx, upsertSurveyAnswer,
		arg.SurveyID,
		arg.QuestionID,
		arg.AnswerText,
		arg.AnswerNumber,
		arg.AnswerBoolean,
		arg.AnswerDate,
	)
	var i SurveyAnswer
	err := row.Scan(
		&i.ID,
		&i.SurveyID,
		&i.QuestionID,
		&i.AnswerText,
		&i.AnswerNumber,
		&i.AnswerBoolean,
		&i.AnswerDate,
		&i.AnsweredAt,
	)
	return i, err
}

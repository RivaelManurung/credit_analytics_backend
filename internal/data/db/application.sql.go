// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: application.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createApplication = `-- name: CreateApplication :one
INSERT INTO applications (
    applicant_id, product_id, ao_id, loan_amount, tenor_months, 
    interest_type, interest_rate, loan_purpose, application_channel, 
    status, branch_code, created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
) RETURNING id, applicant_id, product_id, ao_id, loan_amount, tenor_months, interest_type, interest_rate, loan_purpose, application_channel, status, branch_code, submitted_at, created_at, created_by, updated_at, deleted_at
`

type CreateApplicationParams struct {
	ApplicantID        uuid.UUID      `json:"applicant_id"`
	ProductID          uuid.UUID      `json:"product_id"`
	AoID               uuid.UUID      `json:"ao_id"`
	LoanAmount         sql.NullString `json:"loan_amount"`
	TenorMonths        sql.NullInt32  `json:"tenor_months"`
	InterestType       sql.NullString `json:"interest_type"`
	InterestRate       sql.NullString `json:"interest_rate"`
	LoanPurpose        sql.NullString `json:"loan_purpose"`
	ApplicationChannel sql.NullString `json:"application_channel"`
	Status             string         `json:"status"`
	BranchCode         string         `json:"branch_code"`
	CreatedBy          uuid.NullUUID  `json:"created_by"`
}

func (q *Queries) CreateApplication(ctx context.Context, arg CreateApplicationParams) (Application, error) {
	row := q.db.QueryRowContext(ctx, createApplication,
		arg.ApplicantID,
		arg.ProductID,
		arg.AoID,
		arg.LoanAmount,
		arg.TenorMonths,
		arg.InterestType,
		arg.InterestRate,
		arg.LoanPurpose,
		arg.ApplicationChannel,
		arg.Status,
		arg.BranchCode,
		arg.CreatedBy,
	)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.ApplicantID,
		&i.ProductID,
		&i.AoID,
		&i.LoanAmount,
		&i.TenorMonths,
		&i.InterestType,
		&i.InterestRate,
		&i.LoanPurpose,
		&i.ApplicationChannel,
		&i.Status,
		&i.BranchCode,
		&i.SubmittedAt,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createApplicationParty = `-- name: CreateApplicationParty :one
INSERT INTO application_parties (
    application_id, party_id, role_code, legal_obligation, slik_required
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING application_id, party_id, role_code, legal_obligation, slik_required
`

type CreateApplicationPartyParams struct {
	ApplicationID   uuid.UUID    `json:"application_id"`
	PartyID         uuid.UUID    `json:"party_id"`
	RoleCode        string       `json:"role_code"`
	LegalObligation sql.NullBool `json:"legal_obligation"`
	SlikRequired    sql.NullBool `json:"slik_required"`
}

func (q *Queries) CreateApplicationParty(ctx context.Context, arg CreateApplicationPartyParams) (ApplicationParty, error) {
	row := q.db.QueryRowContext(ctx, createApplicationParty,
		arg.ApplicationID,
		arg.PartyID,
		arg.RoleCode,
		arg.LegalObligation,
		arg.SlikRequired,
	)
	var i ApplicationParty
	err := row.Scan(
		&i.ApplicationID,
		&i.PartyID,
		&i.RoleCode,
		&i.LegalObligation,
		&i.SlikRequired,
	)
	return i, err
}

const createParty = `-- name: CreateParty :one
INSERT INTO parties (
    party_type, identifier, name, date_of_birth
) VALUES (
    $1, $2, $3, $4
) RETURNING id, party_type, identifier, name, date_of_birth
`

type CreatePartyParams struct {
	PartyType   sql.NullString `json:"party_type"`
	Identifier  sql.NullString `json:"identifier"`
	Name        sql.NullString `json:"name"`
	DateOfBirth sql.NullTime   `json:"date_of_birth"`
}

func (q *Queries) CreateParty(ctx context.Context, arg CreatePartyParams) (Party, error) {
	row := q.db.QueryRowContext(ctx, createParty,
		arg.PartyType,
		arg.Identifier,
		arg.Name,
		arg.DateOfBirth,
	)
	var i Party
	err := row.Scan(
		&i.ID,
		&i.PartyType,
		&i.Identifier,
		&i.Name,
		&i.DateOfBirth,
	)
	return i, err
}

const createStatusLog = `-- name: CreateStatusLog :one
INSERT INTO application_status_logs (
    application_id, from_status, to_status, changed_by, change_reason
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, application_id, from_status, to_status, changed_by, change_reason, changed_at
`

type CreateStatusLogParams struct {
	ApplicationID uuid.UUID      `json:"application_id"`
	FromStatus    sql.NullString `json:"from_status"`
	ToStatus      sql.NullString `json:"to_status"`
	ChangedBy     uuid.NullUUID  `json:"changed_by"`
	ChangeReason  sql.NullString `json:"change_reason"`
}

func (q *Queries) CreateStatusLog(ctx context.Context, arg CreateStatusLogParams) (ApplicationStatusLog, error) {
	row := q.db.QueryRowContext(ctx, createStatusLog,
		arg.ApplicationID,
		arg.FromStatus,
		arg.ToStatus,
		arg.ChangedBy,
		arg.ChangeReason,
	)
	var i ApplicationStatusLog
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.FromStatus,
		&i.ToStatus,
		&i.ChangedBy,
		&i.ChangeReason,
		&i.ChangedAt,
	)
	return i, err
}

const deleteApplicationAttributes = `-- name: DeleteApplicationAttributes :exec
DELETE FROM application_attributes WHERE application_id = $1
`

func (q *Queries) DeleteApplicationAttributes(ctx context.Context, applicationID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteApplicationAttributes, applicationID)
	return err
}

const getApplication = `-- name: GetApplication :one
SELECT id, applicant_id, product_id, ao_id, loan_amount, tenor_months, interest_type, interest_rate, loan_purpose, application_channel, status, branch_code, submitted_at, created_at, created_by, updated_at, deleted_at FROM applications WHERE id = $1 AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) GetApplication(ctx context.Context, id uuid.UUID) (Application, error) {
	row := q.db.QueryRowContext(ctx, getApplication, id)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.ApplicantID,
		&i.ProductID,
		&i.AoID,
		&i.LoanAmount,
		&i.TenorMonths,
		&i.InterestType,
		&i.InterestRate,
		&i.LoanPurpose,
		&i.ApplicationChannel,
		&i.Status,
		&i.BranchCode,
		&i.SubmittedAt,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getApplicationAttributes = `-- name: GetApplicationAttributes :many
SELECT id, application_id, attr_key, attr_value, data_type, updated_at FROM application_attributes WHERE application_id = $1
`

func (q *Queries) GetApplicationAttributes(ctx context.Context, applicationID uuid.UUID) ([]ApplicationAttribute, error) {
	rows, err := q.db.QueryContext(ctx, getApplicationAttributes, applicationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApplicationAttribute
	for rows.Next() {
		var i ApplicationAttribute
		if err := rows.Scan(
			&i.ID,
			&i.ApplicationID,
			&i.AttrKey,
			&i.AttrValue,
			&i.DataType,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPartiesByApplication = `-- name: GetPartiesByApplication :many
SELECT p.id, p.party_type, p.identifier, p.name, p.date_of_birth, ap.role_code, ap.legal_obligation, ap.slik_required
FROM parties p
JOIN application_parties ap ON p.id = ap.party_id
WHERE ap.application_id = $1
`

type GetPartiesByApplicationRow struct {
	ID              uuid.UUID      `json:"id"`
	PartyType       sql.NullString `json:"party_type"`
	Identifier      sql.NullString `json:"identifier"`
	Name            sql.NullString `json:"name"`
	DateOfBirth     sql.NullTime   `json:"date_of_birth"`
	RoleCode        string         `json:"role_code"`
	LegalObligation sql.NullBool   `json:"legal_obligation"`
	SlikRequired    sql.NullBool   `json:"slik_required"`
}

func (q *Queries) GetPartiesByApplication(ctx context.Context, applicationID uuid.UUID) ([]GetPartiesByApplicationRow, error) {
	rows, err := q.db.QueryContext(ctx, getPartiesByApplication, applicationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPartiesByApplicationRow
	for rows.Next() {
		var i GetPartiesByApplicationRow
		if err := rows.Scan(
			&i.ID,
			&i.PartyType,
			&i.Identifier,
			&i.Name,
			&i.DateOfBirth,
			&i.RoleCode,
			&i.LegalObligation,
			&i.SlikRequired,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listApplicationAttributesByIDs = `-- name: ListApplicationAttributesByIDs :many
SELECT id, application_id, attr_key, attr_value, data_type, updated_at FROM application_attributes WHERE application_id = ANY($1::uuid[])
`

func (q *Queries) ListApplicationAttributesByIDs(ctx context.Context, dollar_1 []uuid.UUID) ([]ApplicationAttribute, error) {
	rows, err := q.db.QueryContext(ctx, listApplicationAttributesByIDs, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApplicationAttribute
	for rows.Next() {
		var i ApplicationAttribute
		if err := rows.Scan(
			&i.ID,
			&i.ApplicationID,
			&i.AttrKey,
			&i.AttrValue,
			&i.DataType,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listApplications = `-- name: ListApplications :many
SELECT id, applicant_id, product_id, ao_id, loan_amount, tenor_months, interest_type, interest_rate, loan_purpose, application_channel, status, branch_code, submitted_at, created_at, created_by, updated_at, deleted_at FROM applications WHERE deleted_at IS NULL
`

func (q *Queries) ListApplications(ctx context.Context) ([]Application, error) {
	rows, err := q.db.QueryContext(ctx, listApplications)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Application
	for rows.Next() {
		var i Application
		if err := rows.Scan(
			&i.ID,
			&i.ApplicantID,
			&i.ProductID,
			&i.AoID,
			&i.LoanAmount,
			&i.TenorMonths,
			&i.InterestType,
			&i.InterestRate,
			&i.LoanPurpose,
			&i.ApplicationChannel,
			&i.Status,
			&i.BranchCode,
			&i.SubmittedAt,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStatusLogs = `-- name: ListStatusLogs :many
SELECT id, application_id, from_status, to_status, changed_by, change_reason, changed_at FROM application_status_logs WHERE application_id = $1 ORDER BY changed_at DESC
`

func (q *Queries) ListStatusLogs(ctx context.Context, applicationID uuid.UUID) ([]ApplicationStatusLog, error) {
	rows, err := q.db.QueryContext(ctx, listStatusLogs, applicationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApplicationStatusLog
	for rows.Next() {
		var i ApplicationStatusLog
		if err := rows.Scan(
			&i.ID,
			&i.ApplicationID,
			&i.FromStatus,
			&i.ToStatus,
			&i.ChangedBy,
			&i.ChangeReason,
			&i.ChangedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteApplication = `-- name: SoftDeleteApplication :exec
UPDATE applications SET deleted_at = CURRENT_TIMESTAMP WHERE id = $1
`

func (q *Queries) SoftDeleteApplication(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, softDeleteApplication, id)
	return err
}

const updateApplication = `-- name: UpdateApplication :one
UPDATE applications SET 
    applicant_id = $2, 
    product_id = $3, 
    ao_id = $4,
    loan_amount = $5,
    tenor_months = $6,
    interest_type = $7,
    interest_rate = $8,
    loan_purpose = $9,
    status = $10,
    updated_at = CURRENT_TIMESTAMP 
WHERE id = $1 RETURNING id, applicant_id, product_id, ao_id, loan_amount, tenor_months, interest_type, interest_rate, loan_purpose, application_channel, status, branch_code, submitted_at, created_at, created_by, updated_at, deleted_at
`

type UpdateApplicationParams struct {
	ID           uuid.UUID      `json:"id"`
	ApplicantID  uuid.UUID      `json:"applicant_id"`
	ProductID    uuid.UUID      `json:"product_id"`
	AoID         uuid.UUID      `json:"ao_id"`
	LoanAmount   sql.NullString `json:"loan_amount"`
	TenorMonths  sql.NullInt32  `json:"tenor_months"`
	InterestType sql.NullString `json:"interest_type"`
	InterestRate sql.NullString `json:"interest_rate"`
	LoanPurpose  sql.NullString `json:"loan_purpose"`
	Status       string         `json:"status"`
}

func (q *Queries) UpdateApplication(ctx context.Context, arg UpdateApplicationParams) (Application, error) {
	row := q.db.QueryRowContext(ctx, updateApplication,
		arg.ID,
		arg.ApplicantID,
		arg.ProductID,
		arg.AoID,
		arg.LoanAmount,
		arg.TenorMonths,
		arg.InterestType,
		arg.InterestRate,
		arg.LoanPurpose,
		arg.Status,
	)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.ApplicantID,
		&i.ProductID,
		&i.AoID,
		&i.LoanAmount,
		&i.TenorMonths,
		&i.InterestType,
		&i.InterestRate,
		&i.LoanPurpose,
		&i.ApplicationChannel,
		&i.Status,
		&i.BranchCode,
		&i.SubmittedAt,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const upsertApplicationAttribute = `-- name: UpsertApplicationAttribute :one
INSERT INTO application_attributes (application_id, attr_key, attr_value, data_type)
VALUES ($1, $2, $3, $4)
ON CONFLICT (application_id, attr_key) DO UPDATE SET 
    attr_value = EXCLUDED.attr_value,
    data_type = EXCLUDED.data_type,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, application_id, attr_key, attr_value, data_type, updated_at
`

type UpsertApplicationAttributeParams struct {
	ApplicationID uuid.UUID      `json:"application_id"`
	AttrKey       string         `json:"attr_key"`
	AttrValue     sql.NullString `json:"attr_value"`
	DataType      sql.NullString `json:"data_type"`
}

func (q *Queries) UpsertApplicationAttribute(ctx context.Context, arg UpsertApplicationAttributeParams) (ApplicationAttribute, error) {
	row := q.db.QueryRowContext(ctx, upsertApplicationAttribute,
		arg.ApplicationID,
		arg.AttrKey,
		arg.AttrValue,
		arg.DataType,
	)
	var i ApplicationAttribute
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.AttrKey,
		&i.AttrValue,
		&i.DataType,
		&i.UpdatedAt,
	)
	return i, err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: application.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createApplication = `-- name: CreateApplication :one
INSERT INTO applications (
        applicant_id,
        product_id,
        ao_id,
        loan_amount,
        tenor_months,
        interest_type,
        interest_rate,
        loan_purpose,
        application_channel,
        status,
        branch_code,
        created_by
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12
    )
RETURNING id, applicant_id, product_id, ao_id, loan_amount, tenor_months, interest_type, interest_rate, loan_purpose, application_channel, status, branch_code, submitted_at, created_at, created_by
`

type CreateApplicationParams struct {
	ApplicantID        uuid.UUID      `json:"applicant_id"`
	ProductID          uuid.UUID      `json:"product_id"`
	AoID               uuid.UUID      `json:"ao_id"`
	LoanAmount         sql.NullString `json:"loan_amount"`
	TenorMonths        sql.NullInt32  `json:"tenor_months"`
	InterestType       sql.NullString `json:"interest_type"`
	InterestRate       sql.NullString `json:"interest_rate"`
	LoanPurpose        sql.NullString `json:"loan_purpose"`
	ApplicationChannel sql.NullString `json:"application_channel"`
	Status             string         `json:"status"`
	BranchCode         string         `json:"branch_code"`
	CreatedBy          uuid.NullUUID  `json:"created_by"`
}

func (q *Queries) CreateApplication(ctx context.Context, arg CreateApplicationParams) (Application, error) {
	row := q.db.QueryRowContext(ctx, createApplication,
		arg.ApplicantID,
		arg.ProductID,
		arg.AoID,
		arg.LoanAmount,
		arg.TenorMonths,
		arg.InterestType,
		arg.InterestRate,
		arg.LoanPurpose,
		arg.ApplicationChannel,
		arg.Status,
		arg.BranchCode,
		arg.CreatedBy,
	)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.ApplicantID,
		&i.ProductID,
		&i.AoID,
		&i.LoanAmount,
		&i.TenorMonths,
		&i.InterestType,
		&i.InterestRate,
		&i.LoanPurpose,
		&i.ApplicationChannel,
		&i.Status,
		&i.BranchCode,
		&i.SubmittedAt,
		&i.CreatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const createApplicationParty = `-- name: CreateApplicationParty :one
INSERT INTO application_parties (
        application_id,
        party_id,
        role_code,
        legal_obligation,
        slik_required
    )
VALUES ($1, $2, $3, $4, $5)
RETURNING application_id, party_id, role_code, legal_obligation, slik_required
`

type CreateApplicationPartyParams struct {
	ApplicationID   uuid.UUID    `json:"application_id"`
	PartyID         uuid.UUID    `json:"party_id"`
	RoleCode        string       `json:"role_code"`
	LegalObligation sql.NullBool `json:"legal_obligation"`
	SlikRequired    sql.NullBool `json:"slik_required"`
}

func (q *Queries) CreateApplicationParty(ctx context.Context, arg CreateApplicationPartyParams) (ApplicationParty, error) {
	row := q.db.QueryRowContext(ctx, createApplicationParty,
		arg.ApplicationID,
		arg.PartyID,
		arg.RoleCode,
		arg.LegalObligation,
		arg.SlikRequired,
	)
	var i ApplicationParty
	err := row.Scan(
		&i.ApplicationID,
		&i.PartyID,
		&i.RoleCode,
		&i.LegalObligation,
		&i.SlikRequired,
	)
	return i, err
}

const createParty = `-- name: CreateParty :one
INSERT INTO parties (
        party_type,
        identifier,
        name,
        date_of_birth
    )
VALUES ($1, $2, $3, $4)
RETURNING id, party_type, identifier, name, date_of_birth
`

type CreatePartyParams struct {
	PartyType   sql.NullString `json:"party_type"`
	Identifier  sql.NullString `json:"identifier"`
	Name        sql.NullString `json:"name"`
	DateOfBirth sql.NullTime   `json:"date_of_birth"`
}

func (q *Queries) CreateParty(ctx context.Context, arg CreatePartyParams) (Party, error) {
	row := q.db.QueryRowContext(ctx, createParty,
		arg.PartyType,
		arg.Identifier,
		arg.Name,
		arg.DateOfBirth,
	)
	var i Party
	err := row.Scan(
		&i.ID,
		&i.PartyType,
		&i.Identifier,
		&i.Name,
		&i.DateOfBirth,
	)
	return i, err
}

const createStatusLog = `-- name: CreateStatusLog :one
INSERT INTO application_status_logs (
        application_id,
        from_status,
        to_status,
        changed_by,
        change_reason
    )
VALUES ($1, $2, $3, $4, $5)
RETURNING id, application_id, from_status, to_status, changed_by, change_reason, changed_at
`

type CreateStatusLogParams struct {
	ApplicationID uuid.UUID      `json:"application_id"`
	FromStatus    sql.NullString `json:"from_status"`
	ToStatus      sql.NullString `json:"to_status"`
	ChangedBy     uuid.NullUUID  `json:"changed_by"`
	ChangeReason  sql.NullString `json:"change_reason"`
}

func (q *Queries) CreateStatusLog(ctx context.Context, arg CreateStatusLogParams) (ApplicationStatusLog, error) {
	row := q.db.QueryRowContext(ctx, createStatusLog,
		arg.ApplicationID,
		arg.FromStatus,
		arg.ToStatus,
		arg.ChangedBy,
		arg.ChangeReason,
	)
	var i ApplicationStatusLog
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.FromStatus,
		&i.ToStatus,
		&i.ChangedBy,
		&i.ChangeReason,
		&i.ChangedAt,
	)
	return i, err
}

const deleteApplicationAttributes = `-- name: DeleteApplicationAttributes :exec
DELETE FROM application_attributes
WHERE application_id = $1
`

func (q *Queries) DeleteApplicationAttributes(ctx context.Context, applicationID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteApplicationAttributes, applicationID)
	return err
}

const getApplication = `-- name: GetApplication :one
SELECT a.id, a.applicant_id, a.product_id, a.ao_id, a.loan_amount, a.tenor_months, a.interest_type, a.interest_rate, a.loan_purpose, a.application_channel, a.status, a.branch_code, a.submitted_at, a.created_at, a.created_by,
    app.full_name AS applicant_name
FROM applications a
    JOIN applicants app ON a.applicant_id = app.id
WHERE a.id = $1
LIMIT 1
`

type GetApplicationRow struct {
	ID                 uuid.UUID      `json:"id"`
	ApplicantID        uuid.UUID      `json:"applicant_id"`
	ProductID          uuid.UUID      `json:"product_id"`
	AoID               uuid.UUID      `json:"ao_id"`
	LoanAmount         sql.NullString `json:"loan_amount"`
	TenorMonths        sql.NullInt32  `json:"tenor_months"`
	InterestType       sql.NullString `json:"interest_type"`
	InterestRate       sql.NullString `json:"interest_rate"`
	LoanPurpose        sql.NullString `json:"loan_purpose"`
	ApplicationChannel sql.NullString `json:"application_channel"`
	Status             string         `json:"status"`
	BranchCode         string         `json:"branch_code"`
	SubmittedAt        sql.NullTime   `json:"submitted_at"`
	CreatedAt          sql.NullTime   `json:"created_at"`
	CreatedBy          uuid.NullUUID  `json:"created_by"`
	ApplicantName      sql.NullString `json:"applicant_name"`
}

func (q *Queries) GetApplication(ctx context.Context, id uuid.UUID) (GetApplicationRow, error) {
	row := q.db.QueryRowContext(ctx, getApplication, id)
	var i GetApplicationRow
	err := row.Scan(
		&i.ID,
		&i.ApplicantID,
		&i.ProductID,
		&i.AoID,
		&i.LoanAmount,
		&i.TenorMonths,
		&i.InterestType,
		&i.InterestRate,
		&i.LoanPurpose,
		&i.ApplicationChannel,
		&i.Status,
		&i.BranchCode,
		&i.SubmittedAt,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.ApplicantName,
	)
	return i, err
}

const getApplicationAttributes = `-- name: GetApplicationAttributes :many
SELECT id, application_id, attribute_id, attribute_option_id, attr_value, data_type, updated_at
FROM application_attributes
WHERE application_id = $1
`

func (q *Queries) GetApplicationAttributes(ctx context.Context, applicationID uuid.UUID) ([]ApplicationAttribute, error) {
	rows, err := q.db.QueryContext(ctx, getApplicationAttributes, applicationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApplicationAttribute
	for rows.Next() {
		var i ApplicationAttribute
		if err := rows.Scan(
			&i.ID,
			&i.ApplicationID,
			&i.AttributeID,
			&i.AttributeOptionID,
			&i.AttrValue,
			&i.DataType,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPartiesByApplication = `-- name: GetPartiesByApplication :many
SELECT p.id, p.party_type, p.identifier, p.name, p.date_of_birth,
    ap.role_code,
    ap.legal_obligation,
    ap.slik_required
FROM parties p
    JOIN application_parties ap ON p.id = ap.party_id
WHERE ap.application_id = $1
`

type GetPartiesByApplicationRow struct {
	ID              uuid.UUID      `json:"id"`
	PartyType       sql.NullString `json:"party_type"`
	Identifier      sql.NullString `json:"identifier"`
	Name            sql.NullString `json:"name"`
	DateOfBirth     sql.NullTime   `json:"date_of_birth"`
	RoleCode        string         `json:"role_code"`
	LegalObligation sql.NullBool   `json:"legal_obligation"`
	SlikRequired    sql.NullBool   `json:"slik_required"`
}

func (q *Queries) GetPartiesByApplication(ctx context.Context, applicationID uuid.UUID) ([]GetPartiesByApplicationRow, error) {
	rows, err := q.db.QueryContext(ctx, getPartiesByApplication, applicationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPartiesByApplicationRow
	for rows.Next() {
		var i GetPartiesByApplicationRow
		if err := rows.Scan(
			&i.ID,
			&i.PartyType,
			&i.Identifier,
			&i.Name,
			&i.DateOfBirth,
			&i.RoleCode,
			&i.LegalObligation,
			&i.SlikRequired,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listApplicationAttributesByIDs = `-- name: ListApplicationAttributesByIDs :many
SELECT id, application_id, attribute_id, attribute_option_id, attr_value, data_type, updated_at
FROM application_attributes
WHERE application_id = ANY($1::uuid [])
`

func (q *Queries) ListApplicationAttributesByIDs(ctx context.Context, dollar_1 []uuid.UUID) ([]ApplicationAttribute, error) {
	rows, err := q.db.QueryContext(ctx, listApplicationAttributesByIDs, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApplicationAttribute
	for rows.Next() {
		var i ApplicationAttribute
		if err := rows.Scan(
			&i.ID,
			&i.ApplicationID,
			&i.AttributeID,
			&i.AttributeOptionID,
			&i.AttrValue,
			&i.DataType,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listApplications = `-- name: ListApplications :many
SELECT a.id, a.applicant_id, a.product_id, a.ao_id, a.loan_amount, a.tenor_months, a.interest_type, a.interest_rate, a.loan_purpose, a.application_channel, a.status, a.branch_code, a.submitted_at, a.created_at, a.created_by,
    app.full_name AS applicant_name
FROM applications a
    JOIN applicants app ON a.applicant_id = app.id
WHERE (
        $2::text IS NULL
        OR a.status = $2
    )
    AND (
        $3::uuid IS NULL
        OR a.applicant_id = $3
    )
    AND (
        (
            $4::timestamp IS NULL
            AND $5::uuid IS NULL
        )
        OR (a.created_at, a.id) < (
            $4::timestamp,
            $5::uuid
        )
    )
ORDER BY a.created_at DESC,
    a.id DESC
LIMIT $1
`

type ListApplicationsParams struct {
	Limit           int32          `json:"limit"`
	Status          sql.NullString `json:"status"`
	ApplicantID     uuid.NullUUID  `json:"applicant_id"`
	CursorCreatedAt sql.NullTime   `json:"cursor_created_at"`
	CursorID        uuid.NullUUID  `json:"cursor_id"`
}

type ListApplicationsRow struct {
	ID                 uuid.UUID      `json:"id"`
	ApplicantID        uuid.UUID      `json:"applicant_id"`
	ProductID          uuid.UUID      `json:"product_id"`
	AoID               uuid.UUID      `json:"ao_id"`
	LoanAmount         sql.NullString `json:"loan_amount"`
	TenorMonths        sql.NullInt32  `json:"tenor_months"`
	InterestType       sql.NullString `json:"interest_type"`
	InterestRate       sql.NullString `json:"interest_rate"`
	LoanPurpose        sql.NullString `json:"loan_purpose"`
	ApplicationChannel sql.NullString `json:"application_channel"`
	Status             string         `json:"status"`
	BranchCode         string         `json:"branch_code"`
	SubmittedAt        sql.NullTime   `json:"submitted_at"`
	CreatedAt          sql.NullTime   `json:"created_at"`
	CreatedBy          uuid.NullUUID  `json:"created_by"`
	ApplicantName      sql.NullString `json:"applicant_name"`
}

func (q *Queries) ListApplications(ctx context.Context, arg ListApplicationsParams) ([]ListApplicationsRow, error) {
	rows, err := q.db.QueryContext(ctx, listApplications,
		arg.Limit,
		arg.Status,
		arg.ApplicantID,
		arg.CursorCreatedAt,
		arg.CursorID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListApplicationsRow
	for rows.Next() {
		var i ListApplicationsRow
		if err := rows.Scan(
			&i.ID,
			&i.ApplicantID,
			&i.ProductID,
			&i.AoID,
			&i.LoanAmount,
			&i.TenorMonths,
			&i.InterestType,
			&i.InterestRate,
			&i.LoanPurpose,
			&i.ApplicationChannel,
			&i.Status,
			&i.BranchCode,
			&i.SubmittedAt,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.ApplicantName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStatusLogs = `-- name: ListStatusLogs :many
SELECT id, application_id, from_status, to_status, changed_by, change_reason, changed_at
FROM application_status_logs
WHERE application_id = $1
ORDER BY changed_at DESC
`

func (q *Queries) ListStatusLogs(ctx context.Context, applicationID uuid.UUID) ([]ApplicationStatusLog, error) {
	rows, err := q.db.QueryContext(ctx, listStatusLogs, applicationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApplicationStatusLog
	for rows.Next() {
		var i ApplicationStatusLog
		if err := rows.Scan(
			&i.ID,
			&i.ApplicationID,
			&i.FromStatus,
			&i.ToStatus,
			&i.ChangedBy,
			&i.ChangeReason,
			&i.ChangedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateApplication = `-- name: UpdateApplication :one
UPDATE applications
SET applicant_id = $2,
    product_id = $3,
    ao_id = $4,
    loan_amount = $5,
    tenor_months = $6,
    interest_type = $7,
    interest_rate = $8,
    loan_purpose = $9,
    status = $10
WHERE id = $1
RETURNING id, applicant_id, product_id, ao_id, loan_amount, tenor_months, interest_type, interest_rate, loan_purpose, application_channel, status, branch_code, submitted_at, created_at, created_by
`

type UpdateApplicationParams struct {
	ID           uuid.UUID      `json:"id"`
	ApplicantID  uuid.UUID      `json:"applicant_id"`
	ProductID    uuid.UUID      `json:"product_id"`
	AoID         uuid.UUID      `json:"ao_id"`
	LoanAmount   sql.NullString `json:"loan_amount"`
	TenorMonths  sql.NullInt32  `json:"tenor_months"`
	InterestType sql.NullString `json:"interest_type"`
	InterestRate sql.NullString `json:"interest_rate"`
	LoanPurpose  sql.NullString `json:"loan_purpose"`
	Status       string         `json:"status"`
}

func (q *Queries) UpdateApplication(ctx context.Context, arg UpdateApplicationParams) (Application, error) {
	row := q.db.QueryRowContext(ctx, updateApplication,
		arg.ID,
		arg.ApplicantID,
		arg.ProductID,
		arg.AoID,
		arg.LoanAmount,
		arg.TenorMonths,
		arg.InterestType,
		arg.InterestRate,
		arg.LoanPurpose,
		arg.Status,
	)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.ApplicantID,
		&i.ProductID,
		&i.AoID,
		&i.LoanAmount,
		&i.TenorMonths,
		&i.InterestType,
		&i.InterestRate,
		&i.LoanPurpose,
		&i.ApplicationChannel,
		&i.Status,
		&i.BranchCode,
		&i.SubmittedAt,
		&i.CreatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const upsertApplicationAttribute = `-- name: UpsertApplicationAttribute :one
INSERT INTO application_attributes (
        application_id,
        attribute_id,
        attribute_option_id,
        attr_value,
        data_type
    )
VALUES ($1, $2, $3, $4, $5) ON CONFLICT (application_id, attribute_id) DO
UPDATE
SET attribute_option_id = EXCLUDED.attribute_option_id,
    attr_value = EXCLUDED.attr_value,
    data_type = EXCLUDED.data_type,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, application_id, attribute_id, attribute_option_id, attr_value, data_type, updated_at
`

type UpsertApplicationAttributeParams struct {
	ApplicationID     uuid.UUID      `json:"application_id"`
	AttributeID       uuid.UUID      `json:"attribute_id"`
	AttributeOptionID uuid.NullUUID  `json:"attribute_option_id"`
	AttrValue         sql.NullString `json:"attr_value"`
	DataType          sql.NullString `json:"data_type"`
}

func (q *Queries) UpsertApplicationAttribute(ctx context.Context, arg UpsertApplicationAttributeParams) (ApplicationAttribute, error) {
	row := q.db.QueryRowContext(ctx, upsertApplicationAttribute,
		arg.ApplicationID,
		arg.AttributeID,
		arg.AttributeOptionID,
		arg.AttrValue,
		arg.DataType,
	)
	var i ApplicationAttribute
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.AttributeID,
		&i.AttributeOptionID,
		&i.AttrValue,
		&i.DataType,
		&i.UpdatedAt,
	)
	return i, err
}

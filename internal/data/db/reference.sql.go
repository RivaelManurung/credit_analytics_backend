// Code generated by sqlc (manually maintained).
// Regenerate with: make sqlc
// source: reference.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

// -----------------------------------------------------------------------
// LOAN PRODUCTS
// -----------------------------------------------------------------------

const getLoanProduct = `-- name: GetLoanProduct :one
SELECT id, product_code, product_name, segment, active, assignment_mode FROM loan_products WHERE id = $1
`

func (q *Queries) GetLoanProduct(ctx context.Context, id uuid.UUID) (LoanProduct, error) {
	row := q.db.QueryRowContext(ctx, getLoanProduct, id)
	var i LoanProduct
	err := row.Scan(
		&i.ID,
		&i.ProductCode,
		&i.ProductName,
		&i.Segment,
		&i.Active,
		&i.AssignmentMode,
	)
	return i, err
}

const listLoanProducts = `-- name: ListLoanProducts :many
SELECT id, product_code, product_name, segment, active, assignment_mode FROM loan_products WHERE active = TRUE
`

func (q *Queries) ListLoanProducts(ctx context.Context) ([]LoanProduct, error) {
	rows, err := q.db.QueryContext(ctx, listLoanProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LoanProduct
	for rows.Next() {
		var i LoanProduct
		if err := rows.Scan(
			&i.ID,
			&i.ProductCode,
			&i.ProductName,
			&i.Segment,
			&i.Active,
			&i.AssignmentMode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// -----------------------------------------------------------------------
// BRANCHES & OFFICERS
// -----------------------------------------------------------------------

const listBranches = `-- name: ListBranches :many
SELECT branch_code, branch_name, region_code FROM branches
`

func (q *Queries) ListBranches(ctx context.Context) ([]Branch, error) {
	rows, err := q.db.QueryContext(ctx, listBranches)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Branch
	for rows.Next() {
		var i Branch
		if err := rows.Scan(&i.BranchCode, &i.BranchName, &i.RegionCode); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLoanOfficers = `-- name: ListLoanOfficers :many
SELECT id, officer_code, branch_code FROM loan_officers WHERE branch_code = $1
`

func (q *Queries) ListLoanOfficers(ctx context.Context, branchCode string) ([]LoanOfficer, error) {
	rows, err := q.db.QueryContext(ctx, listLoanOfficers, branchCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LoanOfficer
	for rows.Next() {
		var i LoanOfficer
		if err := rows.Scan(&i.ID, &i.OfficerCode, &i.BranchCode); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// -----------------------------------------------------------------------
// APPLICATION STATUSES & FINANCIAL GL ACCOUNTS
// -----------------------------------------------------------------------

const listApplicationStatuses = `-- name: ListApplicationStatuses :many
SELECT status_code, status_group, is_terminal, description FROM application_status_refs
`

func (q *Queries) ListApplicationStatuses(ctx context.Context) ([]ApplicationStatusRef, error) {
	rows, err := q.db.QueryContext(ctx, listApplicationStatuses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApplicationStatusRef
	for rows.Next() {
		var i ApplicationStatusRef
		if err := rows.Scan(
			&i.StatusCode,
			&i.StatusGroup,
			&i.IsTerminal,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFinancialGLAccounts = `-- name: ListFinancialGLAccounts :many
SELECT gl_code, gl_name, statement_type, category, sign, is_debt_service, is_operating, description FROM financial_gl_accounts
`

func (q *Queries) ListFinancialGLAccounts(ctx context.Context) ([]FinancialGlAccount, error) {
	rows, err := q.db.QueryContext(ctx, listFinancialGLAccounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FinancialGlAccount
	for rows.Next() {
		var i FinancialGlAccount
		if err := rows.Scan(
			&i.GlCode,
			&i.GlName,
			&i.StatementType,
			&i.Category,
			&i.Sign,
			&i.IsDebtService,
			&i.IsOperating,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// -----------------------------------------------------------------------
// ATTRIBUTE CATEGORIES (fully dynamic, icon stored here)
// -----------------------------------------------------------------------

// AttributeCategory represents a row in attribute_categories.
type AttributeCategory struct {
	CategoryCode string         `json:"category_code"`
	CategoryName string         `json:"category_name"`
	UiIcon       sql.NullString `json:"ui_icon"`
	DisplayOrder int32          `json:"display_order"`
	Description  sql.NullString `json:"description"`
}

const listAttributeCategories = `-- name: ListAttributeCategories :many
SELECT category_code, category_name, ui_icon, display_order, description
FROM attribute_categories
ORDER BY display_order, category_code
`

func (q *Queries) ListAttributeCategories(ctx context.Context) ([]AttributeCategory, error) {
	rows, err := q.db.QueryContext(ctx, listAttributeCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AttributeCategory
	for rows.Next() {
		var i AttributeCategory
		if err := rows.Scan(
			&i.CategoryCode,
			&i.CategoryName,
			&i.UiIcon,
			&i.DisplayOrder,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttributeCategory = `-- name: GetAttributeCategory :one
SELECT category_code, category_name, ui_icon, display_order, description
FROM attribute_categories WHERE category_code = $1
`

func (q *Queries) GetAttributeCategory(ctx context.Context, categoryCode string) (AttributeCategory, error) {
	row := q.db.QueryRowContext(ctx, getAttributeCategory, categoryCode)
	var i AttributeCategory
	err := row.Scan(
		&i.CategoryCode,
		&i.CategoryName,
		&i.UiIcon,
		&i.DisplayOrder,
		&i.Description,
	)
	return i, err
}

type CreateAttributeCategoryParams struct {
	CategoryCode string         `json:"category_code"`
	CategoryName string         `json:"category_name"`
	UiIcon       sql.NullString `json:"ui_icon"`
	DisplayOrder int32          `json:"display_order"`
	Description  sql.NullString `json:"description"`
}

const createAttributeCategory = `-- name: CreateAttributeCategory :exec
INSERT INTO attribute_categories (category_code, category_name, ui_icon, display_order, description)
VALUES ($1, $2, $3, $4, $5)
`

func (q *Queries) CreateAttributeCategory(ctx context.Context, arg CreateAttributeCategoryParams) error {
	_, err := q.db.ExecContext(ctx, createAttributeCategory,
		arg.CategoryCode,
		arg.CategoryName,
		arg.UiIcon,
		arg.DisplayOrder,
		arg.Description,
	)
	return err
}

type UpdateAttributeCategoryParams struct {
	CategoryCode string         `json:"category_code"`
	CategoryName string         `json:"category_name"`
	UiIcon       sql.NullString `json:"ui_icon"`
	DisplayOrder int32          `json:"display_order"`
	Description  sql.NullString `json:"description"`
}

const updateAttributeCategory = `-- name: UpdateAttributeCategory :exec
UPDATE attribute_categories SET
    category_name = $2, ui_icon = $3, display_order = $4, description = $5
WHERE category_code = $1
`

func (q *Queries) UpdateAttributeCategory(ctx context.Context, arg UpdateAttributeCategoryParams) error {
	_, err := q.db.ExecContext(ctx, updateAttributeCategory,
		arg.CategoryCode,
		arg.CategoryName,
		arg.UiIcon,
		arg.DisplayOrder,
		arg.Description,
	)
	return err
}

const deleteAttributeCategory = `-- name: DeleteAttributeCategory :exec
DELETE FROM attribute_categories WHERE category_code = $1
`

func (q *Queries) DeleteAttributeCategory(ctx context.Context, categoryCode string) error {
	_, err := q.db.ExecContext(ctx, deleteAttributeCategory, categoryCode)
	return err
}

// -----------------------------------------------------------------------
// ATTRIBUTE REGISTRY (JOIN with categories for icon & category_name)
// -----------------------------------------------------------------------

// AttributeRegistryRow is the result of ListAttributeRegistry JOIN query.
// Icon comes from attribute_categories, NOT from this registry.
type AttributeRegistryRow struct {
	AttributeCode string         `json:"attribute_code"`
	AppliesTo     string         `json:"applies_to"`
	Scope         string         `json:"scope"`
	ValueType     string         `json:"value_type"`
	CategoryCode  sql.NullString `json:"category_code"`
	UiLabel       sql.NullString `json:"ui_label"`
	IsRequired    sql.NullBool   `json:"is_required"`
	RiskRelevant  sql.NullBool   `json:"risk_relevant"`
	Description   sql.NullString `json:"description"`
	CategoryName  sql.NullString `json:"category_name"`
	CategoryIcon  sql.NullString `json:"category_icon"`
}

const listAttributeRegistry = `-- name: ListAttributeRegistry :many
SELECT
    r.attribute_code, r.applies_to, r.scope, r.value_type,
    r.category_code, r.ui_label, r.is_required, r.risk_relevant, r.description,
    c.category_name, c.ui_icon AS category_icon
FROM custom_column_attribute_registries r
LEFT JOIN attribute_categories c ON r.category_code = c.category_code
ORDER BY c.display_order, r.attribute_code
`

func (q *Queries) ListAttributeRegistry(ctx context.Context) ([]AttributeRegistryRow, error) {
	rows, err := q.db.QueryContext(ctx, listAttributeRegistry)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AttributeRegistryRow
	for rows.Next() {
		var i AttributeRegistryRow
		if err := rows.Scan(
			&i.AttributeCode,
			&i.AppliesTo,
			&i.Scope,
			&i.ValueType,
			&i.CategoryCode,
			&i.UiLabel,
			&i.IsRequired,
			&i.RiskRelevant,
			&i.Description,
			&i.CategoryName,
			&i.CategoryIcon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAttributeRegistryByCategory = `-- name: ListAttributeRegistryByCategory :many
SELECT
    r.attribute_code, r.applies_to, r.scope, r.value_type,
    r.category_code, r.ui_label, r.is_required, r.risk_relevant, r.description,
    c.category_name, c.ui_icon AS category_icon
FROM custom_column_attribute_registries r
LEFT JOIN attribute_categories c ON r.category_code = c.category_code
WHERE r.category_code = $1
ORDER BY r.attribute_code
`

func (q *Queries) ListAttributeRegistryByCategory(ctx context.Context, categoryCode sql.NullString) ([]AttributeRegistryRow, error) {
	rows, err := q.db.QueryContext(ctx, listAttributeRegistryByCategory, categoryCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AttributeRegistryRow
	for rows.Next() {
		var i AttributeRegistryRow
		if err := rows.Scan(
			&i.AttributeCode,
			&i.AppliesTo,
			&i.Scope,
			&i.ValueType,
			&i.CategoryCode,
			&i.UiLabel,
			&i.IsRequired,
			&i.RiskRelevant,
			&i.Description,
			&i.CategoryName,
			&i.CategoryIcon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

type CreateAttributeRegistryParams struct {
	AttributeCode string         `json:"attribute_code"`
	AppliesTo     string         `json:"applies_to"`
	Scope         string         `json:"scope"`
	ValueType     string         `json:"value_type"`
	CategoryCode  sql.NullString `json:"category_code"`
	UiLabel       sql.NullString `json:"ui_label"`
	IsRequired    sql.NullBool   `json:"is_required"`
	RiskRelevant  sql.NullBool   `json:"risk_relevant"`
	Description   sql.NullString `json:"description"`
}

const createAttributeRegistry = `-- name: CreateAttributeRegistry :exec
INSERT INTO custom_column_attribute_registries (
    attribute_code, applies_to, scope, value_type, category_code, ui_label, is_required, risk_relevant, description
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
`

func (q *Queries) CreateAttributeRegistry(ctx context.Context, arg CreateAttributeRegistryParams) error {
	_, err := q.db.ExecContext(ctx, createAttributeRegistry,
		arg.AttributeCode,
		arg.AppliesTo,
		arg.Scope,
		arg.ValueType,
		arg.CategoryCode,
		arg.UiLabel,
		arg.IsRequired,
		arg.RiskRelevant,
		arg.Description,
	)
	return err
}

type UpdateAttributeRegistryParams struct {
	AttributeCode string         `json:"attribute_code"`
	AppliesTo     string         `json:"applies_to"`
	Scope         string         `json:"scope"`
	ValueType     string         `json:"value_type"`
	CategoryCode  sql.NullString `json:"category_code"`
	UiLabel       sql.NullString `json:"ui_label"`
	IsRequired    sql.NullBool   `json:"is_required"`
	RiskRelevant  sql.NullBool   `json:"risk_relevant"`
	Description   sql.NullString `json:"description"`
}

const updateAttributeRegistry = `-- name: UpdateAttributeRegistry :exec
UPDATE custom_column_attribute_registries SET
    applies_to = $2, scope = $3, value_type = $4,
    category_code = $5, ui_label = $6, is_required = $7, risk_relevant = $8, description = $9
WHERE attribute_code = $1
`

func (q *Queries) UpdateAttributeRegistry(ctx context.Context, arg UpdateAttributeRegistryParams) error {
	_, err := q.db.ExecContext(ctx, updateAttributeRegistry,
		arg.AttributeCode,
		arg.AppliesTo,
		arg.Scope,
		arg.ValueType,
		arg.CategoryCode,
		arg.UiLabel,
		arg.IsRequired,
		arg.RiskRelevant,
		arg.Description,
	)
	return err
}

const deleteAttributeRegistry = `-- name: DeleteAttributeRegistry :exec
DELETE FROM custom_column_attribute_registries WHERE attribute_code = $1
`

func (q *Queries) DeleteAttributeRegistry(ctx context.Context, attributeCode string) error {
	_, err := q.db.ExecContext(ctx, deleteAttributeRegistry, attributeCode)
	return err
}

// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.9.2
// - protoc             v5.29.3
// source: api/decision/v1/decision.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationDecisionCreateCommitteeSession = "/api.decision.v1.Decision/CreateCommitteeSession"
const OperationDecisionFinalizeCommitteeDecision = "/api.decision.v1.Decision/FinalizeCommitteeDecision"
const OperationDecisionGetApplicationDecision = "/api.decision.v1.Decision/GetApplicationDecision"
const OperationDecisionRecordFinalDecision = "/api.decision.v1.Decision/RecordFinalDecision"
const OperationDecisionSubmitCommitteeVote = "/api.decision.v1.Decision/SubmitCommitteeVote"

type DecisionHTTPServer interface {
	CreateCommitteeSession(context.Context, *CreateCommitteeSessionRequest) (*CommitteeSession, error)
	FinalizeCommitteeDecision(context.Context, *FinalizeCommitteeDecisionRequest) (*CommitteeDecision, error)
	GetApplicationDecision(context.Context, *GetApplicationDecisionRequest) (*FinalDecision, error)
	RecordFinalDecision(context.Context, *RecordFinalDecisionRequest) (*FinalDecision, error)
	SubmitCommitteeVote(context.Context, *SubmitCommitteeVoteRequest) (*CommitteeVote, error)
}

func RegisterDecisionHTTPServer(s *http.Server, srv DecisionHTTPServer) {
	r := s.Route("/")
	r.POST("/v1/committee/sessions", _Decision_CreateCommitteeSession0_HTTP_Handler(srv))
	r.POST("/v1/committee/sessions/{committee_session_id}/votes", _Decision_SubmitCommitteeVote0_HTTP_Handler(srv))
	r.POST("/v1/committee/sessions/{committee_session_id}/finalize", _Decision_FinalizeCommitteeDecision0_HTTP_Handler(srv))
	r.POST("/v1/applications/{application_id}/final-decision", _Decision_RecordFinalDecision0_HTTP_Handler(srv))
	r.GET("/v1/applications/{application_id}/decision", _Decision_GetApplicationDecision0_HTTP_Handler(srv))
}

func _Decision_CreateCommitteeSession0_HTTP_Handler(srv DecisionHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateCommitteeSessionRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationDecisionCreateCommitteeSession)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateCommitteeSession(ctx, req.(*CreateCommitteeSessionRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CommitteeSession)
		return ctx.Result(200, reply)
	}
}

func _Decision_SubmitCommitteeVote0_HTTP_Handler(srv DecisionHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SubmitCommitteeVoteRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationDecisionSubmitCommitteeVote)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SubmitCommitteeVote(ctx, req.(*SubmitCommitteeVoteRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CommitteeVote)
		return ctx.Result(200, reply)
	}
}

func _Decision_FinalizeCommitteeDecision0_HTTP_Handler(srv DecisionHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in FinalizeCommitteeDecisionRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationDecisionFinalizeCommitteeDecision)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.FinalizeCommitteeDecision(ctx, req.(*FinalizeCommitteeDecisionRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CommitteeDecision)
		return ctx.Result(200, reply)
	}
}

func _Decision_RecordFinalDecision0_HTTP_Handler(srv DecisionHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in RecordFinalDecisionRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationDecisionRecordFinalDecision)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.RecordFinalDecision(ctx, req.(*RecordFinalDecisionRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*FinalDecision)
		return ctx.Result(200, reply)
	}
}

func _Decision_GetApplicationDecision0_HTTP_Handler(srv DecisionHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetApplicationDecisionRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationDecisionGetApplicationDecision)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetApplicationDecision(ctx, req.(*GetApplicationDecisionRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*FinalDecision)
		return ctx.Result(200, reply)
	}
}

type DecisionHTTPClient interface {
	CreateCommitteeSession(ctx context.Context, req *CreateCommitteeSessionRequest, opts ...http.CallOption) (rsp *CommitteeSession, err error)
	FinalizeCommitteeDecision(ctx context.Context, req *FinalizeCommitteeDecisionRequest, opts ...http.CallOption) (rsp *CommitteeDecision, err error)
	GetApplicationDecision(ctx context.Context, req *GetApplicationDecisionRequest, opts ...http.CallOption) (rsp *FinalDecision, err error)
	RecordFinalDecision(ctx context.Context, req *RecordFinalDecisionRequest, opts ...http.CallOption) (rsp *FinalDecision, err error)
	SubmitCommitteeVote(ctx context.Context, req *SubmitCommitteeVoteRequest, opts ...http.CallOption) (rsp *CommitteeVote, err error)
}

type DecisionHTTPClientImpl struct {
	cc *http.Client
}

func NewDecisionHTTPClient(client *http.Client) DecisionHTTPClient {
	return &DecisionHTTPClientImpl{client}
}

func (c *DecisionHTTPClientImpl) CreateCommitteeSession(ctx context.Context, in *CreateCommitteeSessionRequest, opts ...http.CallOption) (*CommitteeSession, error) {
	var out CommitteeSession
	pattern := "/v1/committee/sessions"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationDecisionCreateCommitteeSession))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *DecisionHTTPClientImpl) FinalizeCommitteeDecision(ctx context.Context, in *FinalizeCommitteeDecisionRequest, opts ...http.CallOption) (*CommitteeDecision, error) {
	var out CommitteeDecision
	pattern := "/v1/committee/sessions/{committee_session_id}/finalize"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationDecisionFinalizeCommitteeDecision))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *DecisionHTTPClientImpl) GetApplicationDecision(ctx context.Context, in *GetApplicationDecisionRequest, opts ...http.CallOption) (*FinalDecision, error) {
	var out FinalDecision
	pattern := "/v1/applications/{application_id}/decision"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationDecisionGetApplicationDecision))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *DecisionHTTPClientImpl) RecordFinalDecision(ctx context.Context, in *RecordFinalDecisionRequest, opts ...http.CallOption) (*FinalDecision, error) {
	var out FinalDecision
	pattern := "/v1/applications/{application_id}/final-decision"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationDecisionRecordFinalDecision))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *DecisionHTTPClientImpl) SubmitCommitteeVote(ctx context.Context, in *SubmitCommitteeVoteRequest, opts ...http.CallOption) (*CommitteeVote, error) {
	var out CommitteeVote
	pattern := "/v1/committee/sessions/{committee_session_id}/votes"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationDecisionSubmitCommitteeVote))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
